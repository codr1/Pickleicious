// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: facility_visits.sql

package db

import (
	"context"
	"database/sql"
	"time"
)

const createFacilityVisit = `-- name: CreateFacilityVisit :one

INSERT INTO facility_visits (
    user_id,
    facility_id,
    check_out_time,
    checked_in_by_staff_id,
    activity_type,
    related_reservation_id
) VALUES (
    ?1,
    ?2,
    ?3,
    ?4,
    ?5,
    ?6
)
RETURNING id, user_id, facility_id, check_in_time, check_out_time,
    checked_in_by_staff_id, activity_type, related_reservation_id,
    created_at, updated_at
`

type CreateFacilityVisitParams struct {
	UserID               int64          `json:"userId"`
	FacilityID           int64          `json:"facilityId"`
	CheckOutTime         sql.NullTime   `json:"checkOutTime"`
	CheckedInByStaffID   sql.NullInt64  `json:"checkedInByStaffId"`
	ActivityType         sql.NullString `json:"activityType"`
	RelatedReservationID sql.NullInt64  `json:"relatedReservationId"`
}

// internal/db/queries/facility_visits.sql
func (q *Queries) CreateFacilityVisit(ctx context.Context, arg CreateFacilityVisitParams) (FacilityVisit, error) {
	row := q.queryRow(ctx, q.createFacilityVisitStmt, createFacilityVisit,
		arg.UserID,
		arg.FacilityID,
		arg.CheckOutTime,
		arg.CheckedInByStaffID,
		arg.ActivityType,
		arg.RelatedReservationID,
	)
	var i FacilityVisit
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.FacilityID,
		&i.CheckInTime,
		&i.CheckOutTime,
		&i.CheckedInByStaffID,
		&i.ActivityType,
		&i.RelatedReservationID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getMemberTodayActivities = `-- name: GetMemberTodayActivities :many
SELECT r.id AS reservation_id,
    r.start_time,
    r.end_time,
    CASE
        WHEN rt.name = 'OPEN_PLAY' THEN 'open_play'
        WHEN rt.name = 'LEAGUE' THEN 'league'
        ELSE 'court_reservation'
    END AS activity_type,
    rt.name AS reservation_type_name,
    COALESCE(
        group_concat(DISTINCT COALESCE(NULLIF(c.name, ''), 'Court ' || c.court_number)),
        ''
    ) AS court_label
FROM reservations r
JOIN reservation_types rt ON rt.id = r.reservation_type_id
LEFT JOIN reservation_courts rc ON rc.reservation_id = r.id
LEFT JOIN courts c ON c.id = rc.court_id
LEFT JOIN reservation_participants rp ON rp.reservation_id = r.id
LEFT JOIN open_play_sessions ops
  ON rt.name = 'OPEN_PLAY'
  AND ops.facility_id = r.facility_id
  AND ops.open_play_rule_id = r.open_play_rule_id
  AND ops.start_time = r.start_time
  AND ops.end_time = r.end_time
  AND ops.status = 'scheduled'
WHERE r.facility_id = ?1
  AND r.start_time >= ?2
  AND r.start_time < ?3
  AND (
    (rt.name = 'OPEN_PLAY' AND rp.user_id = ?4 AND ops.id IS NOT NULL)
    OR (rt.name != 'OPEN_PLAY' AND (r.primary_user_id = ?4 OR rp.user_id = ?4))
  )
GROUP BY r.id, r.start_time, r.end_time, rt.name
ORDER BY r.start_time
`

type GetMemberTodayActivitiesParams struct {
	FacilityID int64     `json:"facilityId"`
	TodayStart time.Time `json:"todayStart"`
	TodayEnd   time.Time `json:"todayEnd"`
	UserID     int64     `json:"userId"`
}

type GetMemberTodayActivitiesRow struct {
	ReservationID       int64       `json:"reservationId"`
	StartTime           time.Time   `json:"startTime"`
	EndTime             time.Time   `json:"endTime"`
	ActivityType        string      `json:"activityType"`
	ReservationTypeName string      `json:"reservationTypeName"`
	CourtLabel          interface{} `json:"courtLabel"`
}

func (q *Queries) GetMemberTodayActivities(ctx context.Context, arg GetMemberTodayActivitiesParams) ([]GetMemberTodayActivitiesRow, error) {
	rows, err := q.query(ctx, q.getMemberTodayActivitiesStmt, getMemberTodayActivities,
		arg.FacilityID,
		arg.TodayStart,
		arg.TodayEnd,
		arg.UserID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetMemberTodayActivitiesRow
	for rows.Next() {
		var i GetMemberTodayActivitiesRow
		if err := rows.Scan(
			&i.ReservationID,
			&i.StartTime,
			&i.EndTime,
			&i.ActivityType,
			&i.ReservationTypeName,
			&i.CourtLabel,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRecentVisitsByUser = `-- name: ListRecentVisitsByUser :many
SELECT id, user_id, facility_id, check_in_time, check_out_time,
    checked_in_by_staff_id, activity_type, related_reservation_id,
    created_at, updated_at
FROM facility_visits
WHERE user_id = ?1
ORDER BY check_in_time DESC
LIMIT 10
`

func (q *Queries) ListRecentVisitsByUser(ctx context.Context, userID int64) ([]FacilityVisit, error) {
	rows, err := q.query(ctx, q.listRecentVisitsByUserStmt, listRecentVisitsByUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FacilityVisit
	for rows.Next() {
		var i FacilityVisit
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.FacilityID,
			&i.CheckInTime,
			&i.CheckOutTime,
			&i.CheckedInByStaffID,
			&i.ActivityType,
			&i.RelatedReservationID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTodayVisitsByFacility = `-- name: ListTodayVisitsByFacility :many
SELECT id, user_id, facility_id, check_in_time, check_out_time,
    checked_in_by_staff_id, activity_type, related_reservation_id,
    created_at, updated_at
FROM facility_visits
WHERE facility_id = ?1
  AND check_in_time >= ?2
  AND check_in_time < ?3
ORDER BY check_in_time DESC
`

type ListTodayVisitsByFacilityParams struct {
	FacilityID int64     `json:"facilityId"`
	TodayStart time.Time `json:"todayStart"`
	TodayEnd   time.Time `json:"todayEnd"`
}

func (q *Queries) ListTodayVisitsByFacility(ctx context.Context, arg ListTodayVisitsByFacilityParams) ([]FacilityVisit, error) {
	rows, err := q.query(ctx, q.listTodayVisitsByFacilityStmt, listTodayVisitsByFacility, arg.FacilityID, arg.TodayStart, arg.TodayEnd)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FacilityVisit
	for rows.Next() {
		var i FacilityVisit
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.FacilityID,
			&i.CheckInTime,
			&i.CheckOutTime,
			&i.CheckedInByStaffID,
			&i.ActivityType,
			&i.RelatedReservationID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateFacilityVisitActivity = `-- name: UpdateFacilityVisitActivity :one
UPDATE facility_visits
SET activity_type = ?1,
    related_reservation_id = ?2,
    updated_at = CURRENT_TIMESTAMP
WHERE id = ?3
  AND user_id = ?4
  AND facility_id = ?5
RETURNING id, user_id, facility_id, check_in_time, check_out_time,
    checked_in_by_staff_id, activity_type, related_reservation_id,
    created_at, updated_at
`

type UpdateFacilityVisitActivityParams struct {
	ActivityType         sql.NullString `json:"activityType"`
	RelatedReservationID sql.NullInt64  `json:"relatedReservationId"`
	ID                   int64          `json:"id"`
	UserID               int64          `json:"userId"`
	FacilityID           int64          `json:"facilityId"`
}

func (q *Queries) UpdateFacilityVisitActivity(ctx context.Context, arg UpdateFacilityVisitActivityParams) (FacilityVisit, error) {
	row := q.queryRow(ctx, q.updateFacilityVisitActivityStmt, updateFacilityVisitActivity,
		arg.ActivityType,
		arg.RelatedReservationID,
		arg.ID,
		arg.UserID,
		arg.FacilityID,
	)
	var i FacilityVisit
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.FacilityID,
		&i.CheckInTime,
		&i.CheckOutTime,
		&i.CheckedInByStaffID,
		&i.ActivityType,
		&i.RelatedReservationID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

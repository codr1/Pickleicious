// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: staff.sql

package db

import (
	"context"
	"database/sql"
	"time"
)

const createProUnavailability = `-- name: CreateProUnavailability :execlastid
INSERT INTO pro_unavailability (
    pro_id, start_time, end_time, reason
) VALUES (
    ?1, ?2, ?3, ?4
)
`

type CreateProUnavailabilityParams struct {
	ProID     int64          `json:"proId"`
	StartTime time.Time      `json:"startTime"`
	EndTime   time.Time      `json:"endTime"`
	Reason    sql.NullString `json:"reason"`
}

func (q *Queries) CreateProUnavailability(ctx context.Context, arg CreateProUnavailabilityParams) (int64, error) {
	result, err := q.exec(ctx, q.createProUnavailabilityStmt, createProUnavailability,
		arg.ProID,
		arg.StartTime,
		arg.EndTime,
		arg.Reason,
	)
	if err != nil {
		return 0, err
	}
	return result.LastInsertId()
}

const createStaff = `-- name: CreateStaff :execlastid
INSERT INTO staff (
    user_id, first_name, last_name, home_facility_id, role
) VALUES (
    ?1, ?2, ?3, ?4, ?5
)
`

type CreateStaffParams struct {
	UserID         int64         `json:"userId"`
	FirstName      string        `json:"firstName"`
	LastName       string        `json:"lastName"`
	HomeFacilityID sql.NullInt64 `json:"homeFacilityId"`
	Role           string        `json:"role"`
}

func (q *Queries) CreateStaff(ctx context.Context, arg CreateStaffParams) (int64, error) {
	result, err := q.exec(ctx, q.createStaffStmt, createStaff,
		arg.UserID,
		arg.FirstName,
		arg.LastName,
		arg.HomeFacilityID,
		arg.Role,
	)
	if err != nil {
		return 0, err
	}
	return result.LastInsertId()
}

const deleteProUnavailability = `-- name: DeleteProUnavailability :exec
DELETE FROM pro_unavailability
WHERE id = ?1
`

func (q *Queries) DeleteProUnavailability(ctx context.Context, id int64) error {
	_, err := q.exec(ctx, q.deleteProUnavailabilityStmt, deleteProUnavailability, id)
	return err
}

const deleteStaff = `-- name: DeleteStaff :exec
DELETE FROM staff WHERE id = ?1
`

func (q *Queries) DeleteStaff(ctx context.Context, id int64) error {
	_, err := q.exec(ctx, q.deleteStaffStmt, deleteStaff, id)
	return err
}

const getFutureProSessionsByStaffID = `-- name: GetFutureProSessionsByStaffID :many
SELECT id, facility_id, reservation_type_id, recurrence_rule_id,
    primary_user_id, pro_id, open_play_rule_id, start_time, end_time,
    is_open_event, teams_per_court, people_per_team
FROM reservations
WHERE pro_id = ?1
  AND start_time > ?2
ORDER BY start_time
`

type GetFutureProSessionsByStaffIDParams struct {
	ProID     sql.NullInt64 `json:"proId"`
	StartTime time.Time     `json:"startTime"`
}

type GetFutureProSessionsByStaffIDRow struct {
	ID                int64         `json:"id"`
	FacilityID        int64         `json:"facilityId"`
	ReservationTypeID int64         `json:"reservationTypeId"`
	RecurrenceRuleID  sql.NullInt64 `json:"recurrenceRuleId"`
	PrimaryUserID     sql.NullInt64 `json:"primaryUserId"`
	ProID             sql.NullInt64 `json:"proId"`
	OpenPlayRuleID    sql.NullInt64 `json:"openPlayRuleId"`
	StartTime         time.Time     `json:"startTime"`
	EndTime           time.Time     `json:"endTime"`
	IsOpenEvent       bool          `json:"isOpenEvent"`
	TeamsPerCourt     sql.NullInt64 `json:"teamsPerCourt"`
	PeoplePerTeam     sql.NullInt64 `json:"peoplePerTeam"`
}

func (q *Queries) GetFutureProSessionsByStaffID(ctx context.Context, arg GetFutureProSessionsByStaffIDParams) ([]GetFutureProSessionsByStaffIDRow, error) {
	rows, err := q.query(ctx, q.getFutureProSessionsByStaffIDStmt, getFutureProSessionsByStaffID, arg.ProID, arg.StartTime)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetFutureProSessionsByStaffIDRow
	for rows.Next() {
		var i GetFutureProSessionsByStaffIDRow
		if err := rows.Scan(
			&i.ID,
			&i.FacilityID,
			&i.ReservationTypeID,
			&i.RecurrenceRuleID,
			&i.PrimaryUserID,
			&i.ProID,
			&i.OpenPlayRuleID,
			&i.StartTime,
			&i.EndTime,
			&i.IsOpenEvent,
			&i.TeamsPerCourt,
			&i.PeoplePerTeam,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProLessonSlots = `-- name: GetProLessonSlots :many
WITH RECURSIVE
    hours AS (
        SELECT
            datetime(date(?1) || ' ' || oh.opens_at) AS day_open,
            datetime(date(?1) || ' ' || oh.closes_at) AS day_close
        FROM operating_hours oh
        WHERE oh.facility_id = ?2
          AND oh.day_of_week = CAST(strftime('%w', date(?1)) AS INTEGER)
    ),
    slots AS (
        SELECT
            hours.day_open AS start_time,
            datetime(hours.day_open, '+' || ?3 || ' minutes') AS end_time
        FROM hours
        WHERE datetime(hours.day_open, '+' || ?3 || ' minutes') <= hours.day_close
        UNION ALL
        SELECT
            datetime(slots.start_time, '+' || ?3 || ' minutes'),
            datetime(slots.end_time, '+' || ?3 || ' minutes')
        FROM slots, hours
        WHERE slots.end_time < hours.day_close
    ),
    busy AS (
        SELECT r.start_time, r.end_time
        FROM reservations r
        JOIN hours ON r.start_time < hours.day_close AND r.end_time > hours.day_open
        WHERE r.pro_id = ?4
        UNION ALL
        SELECT pu.start_time, pu.end_time
        FROM pro_unavailability pu
        JOIN hours ON pu.start_time < hours.day_close AND pu.end_time > hours.day_open
        WHERE pu.pro_id = ?4
    )
SELECT slots.start_time, slots.end_time
FROM slots
WHERE NOT EXISTS (
    SELECT 1
    FROM busy
    WHERE busy.start_time < slots.end_time
      AND busy.end_time > slots.start_time
)
ORDER BY slots.start_time
`

type GetProLessonSlotsParams struct {
	TargetDate  interface{}    `json:"targetDate"`
	FacilityID  int64          `json:"facilityId"`
	SlotMinutes sql.NullString `json:"slotMinutes"`
	ProID       sql.NullInt64  `json:"proId"`
}

type GetProLessonSlotsRow struct {
	StartTime interface{} `json:"startTime"`
	EndTime   interface{} `json:"endTime"`
}

func (q *Queries) GetProLessonSlots(ctx context.Context, arg GetProLessonSlotsParams) ([]GetProLessonSlotsRow, error) {
	rows, err := q.query(ctx, q.getProLessonSlotsStmt, getProLessonSlots,
		arg.TargetDate,
		arg.FacilityID,
		arg.SlotMinutes,
		arg.ProID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetProLessonSlotsRow
	for rows.Next() {
		var i GetProLessonSlotsRow
		if err := rows.Scan(&i.StartTime, &i.EndTime); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProUnavailabilityByID = `-- name: GetProUnavailabilityByID :one
SELECT id, pro_id, start_time, end_time, reason, created_at, updated_at
FROM pro_unavailability
WHERE id = ?1
`

func (q *Queries) GetProUnavailabilityByID(ctx context.Context, id int64) (ProUnavailability, error) {
	row := q.queryRow(ctx, q.getProUnavailabilityByIDStmt, getProUnavailabilityByID, id)
	var i ProUnavailability
	err := row.Scan(
		&i.ID,
		&i.ProID,
		&i.StartTime,
		&i.EndTime,
		&i.Reason,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getStaffByEmail = `-- name: GetStaffByEmail :one
SELECT
    s.id, s.user_id, s.first_name, s.last_name, s.home_facility_id, s.role, s.created_at, s.updated_at,
    u.email,
    u.phone,
    u.local_auth_enabled,
    u.password_hash,
    u.status as user_status
FROM staff s
JOIN users u ON u.id = s.user_id
WHERE u.email = ?1 AND u.status <> 'deleted'
`

type GetStaffByEmailRow struct {
	ID               int64          `json:"id"`
	UserID           int64          `json:"userId"`
	FirstName        string         `json:"firstName"`
	LastName         string         `json:"lastName"`
	HomeFacilityID   sql.NullInt64  `json:"homeFacilityId"`
	Role             string         `json:"role"`
	CreatedAt        time.Time      `json:"createdAt"`
	UpdatedAt        time.Time      `json:"updatedAt"`
	Email            sql.NullString `json:"email"`
	Phone            sql.NullString `json:"phone"`
	LocalAuthEnabled bool           `json:"localAuthEnabled"`
	PasswordHash     sql.NullString `json:"passwordHash"`
	UserStatus       string         `json:"userStatus"`
}

func (q *Queries) GetStaffByEmail(ctx context.Context, email sql.NullString) (GetStaffByEmailRow, error) {
	row := q.queryRow(ctx, q.getStaffByEmailStmt, getStaffByEmail, email)
	var i GetStaffByEmailRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.FirstName,
		&i.LastName,
		&i.HomeFacilityID,
		&i.Role,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Email,
		&i.Phone,
		&i.LocalAuthEnabled,
		&i.PasswordHash,
		&i.UserStatus,
	)
	return i, err
}

const getStaffByID = `-- name: GetStaffByID :one
SELECT
    s.id, s.user_id, s.first_name, s.last_name, s.home_facility_id, s.role, s.created_at, s.updated_at,
    u.email,
    u.phone,
    u.local_auth_enabled,
    u.password_hash,
    u.status as user_status
FROM staff s
JOIN users u ON u.id = s.user_id
WHERE s.id = ?1
`

type GetStaffByIDRow struct {
	ID               int64          `json:"id"`
	UserID           int64          `json:"userId"`
	FirstName        string         `json:"firstName"`
	LastName         string         `json:"lastName"`
	HomeFacilityID   sql.NullInt64  `json:"homeFacilityId"`
	Role             string         `json:"role"`
	CreatedAt        time.Time      `json:"createdAt"`
	UpdatedAt        time.Time      `json:"updatedAt"`
	Email            sql.NullString `json:"email"`
	Phone            sql.NullString `json:"phone"`
	LocalAuthEnabled bool           `json:"localAuthEnabled"`
	PasswordHash     sql.NullString `json:"passwordHash"`
	UserStatus       string         `json:"userStatus"`
}

func (q *Queries) GetStaffByID(ctx context.Context, id int64) (GetStaffByIDRow, error) {
	row := q.queryRow(ctx, q.getStaffByIDStmt, getStaffByID, id)
	var i GetStaffByIDRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.FirstName,
		&i.LastName,
		&i.HomeFacilityID,
		&i.Role,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Email,
		&i.Phone,
		&i.LocalAuthEnabled,
		&i.PasswordHash,
		&i.UserStatus,
	)
	return i, err
}

const getStaffByPhone = `-- name: GetStaffByPhone :one
SELECT
    s.id, s.user_id, s.first_name, s.last_name, s.home_facility_id, s.role, s.created_at, s.updated_at,
    u.email,
    u.phone,
    u.local_auth_enabled,
    u.password_hash,
    u.status as user_status
FROM staff s
JOIN users u ON u.id = s.user_id
WHERE u.phone = ?1 AND u.status <> 'deleted'
`

type GetStaffByPhoneRow struct {
	ID               int64          `json:"id"`
	UserID           int64          `json:"userId"`
	FirstName        string         `json:"firstName"`
	LastName         string         `json:"lastName"`
	HomeFacilityID   sql.NullInt64  `json:"homeFacilityId"`
	Role             string         `json:"role"`
	CreatedAt        time.Time      `json:"createdAt"`
	UpdatedAt        time.Time      `json:"updatedAt"`
	Email            sql.NullString `json:"email"`
	Phone            sql.NullString `json:"phone"`
	LocalAuthEnabled bool           `json:"localAuthEnabled"`
	PasswordHash     sql.NullString `json:"passwordHash"`
	UserStatus       string         `json:"userStatus"`
}

func (q *Queries) GetStaffByPhone(ctx context.Context, phone sql.NullString) (GetStaffByPhoneRow, error) {
	row := q.queryRow(ctx, q.getStaffByPhoneStmt, getStaffByPhone, phone)
	var i GetStaffByPhoneRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.FirstName,
		&i.LastName,
		&i.HomeFacilityID,
		&i.Role,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Email,
		&i.Phone,
		&i.LocalAuthEnabled,
		&i.PasswordHash,
		&i.UserStatus,
	)
	return i, err
}

const getStaffByUserID = `-- name: GetStaffByUserID :one
SELECT
    s.id, s.user_id, s.first_name, s.last_name, s.home_facility_id, s.role, s.created_at, s.updated_at,
    u.email,
    u.phone,
    u.local_auth_enabled,
    u.password_hash,
    u.status as user_status
FROM staff s
JOIN users u ON u.id = s.user_id
WHERE s.user_id = ?1
`

type GetStaffByUserIDRow struct {
	ID               int64          `json:"id"`
	UserID           int64          `json:"userId"`
	FirstName        string         `json:"firstName"`
	LastName         string         `json:"lastName"`
	HomeFacilityID   sql.NullInt64  `json:"homeFacilityId"`
	Role             string         `json:"role"`
	CreatedAt        time.Time      `json:"createdAt"`
	UpdatedAt        time.Time      `json:"updatedAt"`
	Email            sql.NullString `json:"email"`
	Phone            sql.NullString `json:"phone"`
	LocalAuthEnabled bool           `json:"localAuthEnabled"`
	PasswordHash     sql.NullString `json:"passwordHash"`
	UserStatus       string         `json:"userStatus"`
}

func (q *Queries) GetStaffByUserID(ctx context.Context, userID int64) (GetStaffByUserIDRow, error) {
	row := q.queryRow(ctx, q.getStaffByUserIDStmt, getStaffByUserID, userID)
	var i GetStaffByUserIDRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.FirstName,
		&i.LastName,
		&i.HomeFacilityID,
		&i.Role,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Email,
		&i.Phone,
		&i.LocalAuthEnabled,
		&i.PasswordHash,
		&i.UserStatus,
	)
	return i, err
}

const listProUnavailabilityByFacilityAndDateRange = `-- name: ListProUnavailabilityByFacilityAndDateRange :many
SELECT pu.id, pu.pro_id, pu.start_time, pu.end_time, pu.reason, pu.created_at, pu.updated_at
FROM pro_unavailability pu
JOIN staff s ON s.id = pu.pro_id
WHERE s.home_facility_id = ?1
  AND pu.start_time < ?2
  AND pu.end_time > ?3
ORDER BY pu.start_time
`

type ListProUnavailabilityByFacilityAndDateRangeParams struct {
	FacilityID sql.NullInt64 `json:"facilityId"`
	EndTime    time.Time     `json:"endTime"`
	StartTime  time.Time     `json:"startTime"`
}

func (q *Queries) ListProUnavailabilityByFacilityAndDateRange(ctx context.Context, arg ListProUnavailabilityByFacilityAndDateRangeParams) ([]ProUnavailability, error) {
	rows, err := q.query(ctx, q.listProUnavailabilityByFacilityAndDateRangeStmt, listProUnavailabilityByFacilityAndDateRange, arg.FacilityID, arg.EndTime, arg.StartTime)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ProUnavailability
	for rows.Next() {
		var i ProUnavailability
		if err := rows.Scan(
			&i.ID,
			&i.ProID,
			&i.StartTime,
			&i.EndTime,
			&i.Reason,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProUnavailabilityByProID = `-- name: ListProUnavailabilityByProID :many
SELECT id, pro_id, start_time, end_time, reason, created_at, updated_at
FROM pro_unavailability
WHERE pro_id = ?1
ORDER BY start_time
`

func (q *Queries) ListProUnavailabilityByProID(ctx context.Context, proID int64) ([]ProUnavailability, error) {
	rows, err := q.query(ctx, q.listProUnavailabilityByProIDStmt, listProUnavailabilityByProID, proID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ProUnavailability
	for rows.Next() {
		var i ProUnavailability
		if err := rows.Scan(
			&i.ID,
			&i.ProID,
			&i.StartTime,
			&i.EndTime,
			&i.Reason,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProsByFacility = `-- name: ListProsByFacility :many
SELECT
    s.id, s.user_id, s.first_name, s.last_name, s.home_facility_id, s.role, s.created_at, s.updated_at,
    u.email,
    u.phone
FROM staff s
JOIN users u ON u.id = s.user_id
WHERE s.home_facility_id = ?1
    AND s.role = 'pro'
    AND u.status <> 'deleted'
ORDER BY s.last_name, s.first_name
`

type ListProsByFacilityRow struct {
	ID             int64          `json:"id"`
	UserID         int64          `json:"userId"`
	FirstName      string         `json:"firstName"`
	LastName       string         `json:"lastName"`
	HomeFacilityID sql.NullInt64  `json:"homeFacilityId"`
	Role           string         `json:"role"`
	CreatedAt      time.Time      `json:"createdAt"`
	UpdatedAt      time.Time      `json:"updatedAt"`
	Email          sql.NullString `json:"email"`
	Phone          sql.NullString `json:"phone"`
}

func (q *Queries) ListProsByFacility(ctx context.Context, facilityID sql.NullInt64) ([]ListProsByFacilityRow, error) {
	rows, err := q.query(ctx, q.listProsByFacilityStmt, listProsByFacility, facilityID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListProsByFacilityRow
	for rows.Next() {
		var i ListProsByFacilityRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.FirstName,
			&i.LastName,
			&i.HomeFacilityID,
			&i.Role,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Email,
			&i.Phone,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listStaff = `-- name: ListStaff :many

SELECT
    s.id, s.user_id, s.first_name, s.last_name, s.home_facility_id, s.role, s.created_at, s.updated_at,
    u.email,
    u.phone,
    u.local_auth_enabled,
    u.status as user_status
FROM staff s
JOIN users u ON u.id = s.user_id
WHERE u.status <> 'deleted'
ORDER BY s.last_name, s.first_name
`

type ListStaffRow struct {
	ID               int64          `json:"id"`
	UserID           int64          `json:"userId"`
	FirstName        string         `json:"firstName"`
	LastName         string         `json:"lastName"`
	HomeFacilityID   sql.NullInt64  `json:"homeFacilityId"`
	Role             string         `json:"role"`
	CreatedAt        time.Time      `json:"createdAt"`
	UpdatedAt        time.Time      `json:"updatedAt"`
	Email            sql.NullString `json:"email"`
	Phone            sql.NullString `json:"phone"`
	LocalAuthEnabled bool           `json:"localAuthEnabled"`
	UserStatus       string         `json:"userStatus"`
}

// internal/db/queries/staff.sql
// Queries for staff members (join staff table with users for auth/contact info)
func (q *Queries) ListStaff(ctx context.Context) ([]ListStaffRow, error) {
	rows, err := q.query(ctx, q.listStaffStmt, listStaff)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListStaffRow
	for rows.Next() {
		var i ListStaffRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.FirstName,
			&i.LastName,
			&i.HomeFacilityID,
			&i.Role,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Email,
			&i.Phone,
			&i.LocalAuthEnabled,
			&i.UserStatus,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listStaffByFacility = `-- name: ListStaffByFacility :many
SELECT
    s.id, s.user_id, s.first_name, s.last_name, s.home_facility_id, s.role, s.created_at, s.updated_at,
    u.email,
    u.phone
FROM staff s
JOIN users u ON u.id = s.user_id
WHERE s.home_facility_id = ?1
    AND u.status <> 'deleted'
ORDER BY s.last_name, s.first_name
`

type ListStaffByFacilityRow struct {
	ID             int64          `json:"id"`
	UserID         int64          `json:"userId"`
	FirstName      string         `json:"firstName"`
	LastName       string         `json:"lastName"`
	HomeFacilityID sql.NullInt64  `json:"homeFacilityId"`
	Role           string         `json:"role"`
	CreatedAt      time.Time      `json:"createdAt"`
	UpdatedAt      time.Time      `json:"updatedAt"`
	Email          sql.NullString `json:"email"`
	Phone          sql.NullString `json:"phone"`
}

func (q *Queries) ListStaffByFacility(ctx context.Context, facilityID sql.NullInt64) ([]ListStaffByFacilityRow, error) {
	rows, err := q.query(ctx, q.listStaffByFacilityStmt, listStaffByFacility, facilityID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListStaffByFacilityRow
	for rows.Next() {
		var i ListStaffByFacilityRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.FirstName,
			&i.LastName,
			&i.HomeFacilityID,
			&i.Role,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Email,
			&i.Phone,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listStaffByRole = `-- name: ListStaffByRole :many
SELECT
    s.id, s.user_id, s.first_name, s.last_name, s.home_facility_id, s.role, s.created_at, s.updated_at,
    u.email,
    u.phone
FROM staff s
JOIN users u ON u.id = s.user_id
WHERE s.role = ?1
    AND u.status <> 'deleted'
ORDER BY s.last_name, s.first_name
`

type ListStaffByRoleRow struct {
	ID             int64          `json:"id"`
	UserID         int64          `json:"userId"`
	FirstName      string         `json:"firstName"`
	LastName       string         `json:"lastName"`
	HomeFacilityID sql.NullInt64  `json:"homeFacilityId"`
	Role           string         `json:"role"`
	CreatedAt      time.Time      `json:"createdAt"`
	UpdatedAt      time.Time      `json:"updatedAt"`
	Email          sql.NullString `json:"email"`
	Phone          sql.NullString `json:"phone"`
}

func (q *Queries) ListStaffByRole(ctx context.Context, role string) ([]ListStaffByRoleRow, error) {
	rows, err := q.query(ctx, q.listStaffByRoleStmt, listStaffByRole, role)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListStaffByRoleRow
	for rows.Next() {
		var i ListStaffByRoleRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.FirstName,
			&i.LastName,
			&i.HomeFacilityID,
			&i.Role,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Email,
			&i.Phone,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateStaff = `-- name: UpdateStaff :exec
UPDATE staff
SET first_name = ?1,
    last_name = ?2,
    home_facility_id = ?3,
    role = ?4,
    updated_at = CURRENT_TIMESTAMP
WHERE id = ?5
`

type UpdateStaffParams struct {
	FirstName      string        `json:"firstName"`
	LastName       string        `json:"lastName"`
	HomeFacilityID sql.NullInt64 `json:"homeFacilityId"`
	Role           string        `json:"role"`
	ID             int64         `json:"id"`
}

func (q *Queries) UpdateStaff(ctx context.Context, arg UpdateStaffParams) error {
	_, err := q.exec(ctx, q.updateStaffStmt, updateStaff,
		arg.FirstName,
		arg.LastName,
		arg.HomeFacilityID,
		arg.Role,
		arg.ID,
	)
	return err
}

// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: waitlist.sql

package db

import (
	"context"
	"database/sql"
	"time"
)

const acceptOffer = `-- name: AcceptOffer :one
UPDATE waitlist_offers
SET status = 'accepted'
WHERE id = ?1
  AND waitlist_id = ?2
RETURNING
    id,
    waitlist_id,
    offered_at,
    expires_at,
    status
`

type AcceptOfferParams struct {
	ID         int64 `json:"id"`
	WaitlistID int64 `json:"waitlistId"`
}

func (q *Queries) AcceptOffer(ctx context.Context, arg AcceptOfferParams) (WaitlistOffer, error) {
	row := q.queryRow(ctx, q.acceptOfferStmt, acceptOffer, arg.ID, arg.WaitlistID)
	var i WaitlistOffer
	err := row.Scan(
		&i.ID,
		&i.WaitlistID,
		&i.OfferedAt,
		&i.ExpiresAt,
		&i.Status,
	)
	return i, err
}

const advanceWaitlistOffer = `-- name: AdvanceWaitlistOffer :one
INSERT INTO waitlist_offers (waitlist_id, expires_at, status)
SELECT w.id, ?1, 'pending'
FROM waitlists w
JOIN waitlists c ON c.id = ?2
WHERE w.facility_id = c.facility_id
  AND w.target_date = c.target_date
  AND w.target_start_time = c.target_start_time
  AND w.target_end_time = c.target_end_time
  AND (
      w.target_court_id = c.target_court_id
      OR (w.target_court_id IS NULL AND c.target_court_id IS NULL)
  )
  AND w.position = (
      SELECT MIN(w2.position)
      FROM waitlists w2
      WHERE w2.facility_id = c.facility_id
        AND w2.target_date = c.target_date
        AND w2.target_start_time = c.target_start_time
        AND w2.target_end_time = c.target_end_time
        AND (
            w2.target_court_id = c.target_court_id
            OR (w2.target_court_id IS NULL AND c.target_court_id IS NULL)
        )
        AND w2.position > c.position
        AND w2.status = 'pending'
  )
RETURNING
    id,
    waitlist_id,
    offered_at,
    expires_at,
    status
`

type AdvanceWaitlistOfferParams struct {
	ExpiresAt  time.Time `json:"expiresAt"`
	WaitlistID int64     `json:"waitlistId"`
}

func (q *Queries) AdvanceWaitlistOffer(ctx context.Context, arg AdvanceWaitlistOfferParams) (WaitlistOffer, error) {
	row := q.queryRow(ctx, q.advanceWaitlistOfferStmt, advanceWaitlistOffer, arg.ExpiresAt, arg.WaitlistID)
	var i WaitlistOffer
	err := row.Scan(
		&i.ID,
		&i.WaitlistID,
		&i.OfferedAt,
		&i.ExpiresAt,
		&i.Status,
	)
	return i, err
}

const createWaitlistEntry = `-- name: CreateWaitlistEntry :one
INSERT INTO waitlists (
    facility_id,
    user_id,
    target_court_id,
    target_date,
    target_start_time,
    target_end_time,
    position,
    status
) SELECT
    ?1,
    ?2,
    ?3,
    ?4,
    ?5,
    ?6,
    COALESCE(MAX(position), 0) + 1,
    ?7
FROM waitlists
WHERE facility_id = ?1
  AND target_date = ?4
  AND target_start_time = ?5
  AND target_end_time = ?6
  AND (
      target_court_id = ?3
      OR (?3 IS NULL AND target_court_id IS NULL)
  )
RETURNING
    id,
    facility_id,
    user_id,
    target_court_id,
    target_date,
    target_start_time,
    target_end_time,
    position,
    status,
    created_at,
    updated_at
`

type CreateWaitlistEntryParams struct {
	FacilityID      int64         `json:"facilityId"`
	UserID          int64         `json:"userId"`
	TargetCourtID   sql.NullInt64 `json:"targetCourtId"`
	TargetDate      time.Time     `json:"targetDate"`
	TargetStartTime interface{}   `json:"targetStartTime"`
	TargetEndTime   interface{}   `json:"targetEndTime"`
	Status          string        `json:"status"`
}

// internal/db/queries/waitlist.sql
func (q *Queries) CreateWaitlistEntry(ctx context.Context, arg CreateWaitlistEntryParams) (Waitlist, error) {
	row := q.queryRow(ctx, q.createWaitlistEntryStmt, createWaitlistEntry,
		arg.FacilityID,
		arg.UserID,
		arg.TargetCourtID,
		arg.TargetDate,
		arg.TargetStartTime,
		arg.TargetEndTime,
		arg.Status,
	)
	var i Waitlist
	err := row.Scan(
		&i.ID,
		&i.FacilityID,
		&i.UserID,
		&i.TargetCourtID,
		&i.TargetDate,
		&i.TargetStartTime,
		&i.TargetEndTime,
		&i.Position,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createWaitlistOffer = `-- name: CreateWaitlistOffer :one
INSERT INTO waitlist_offers (
    waitlist_id,
    expires_at,
    status
) VALUES (
    ?1,
    ?2,
    ?3
)
RETURNING
    id,
    waitlist_id,
    offered_at,
    expires_at,
    status
`

type CreateWaitlistOfferParams struct {
	WaitlistID int64     `json:"waitlistId"`
	ExpiresAt  time.Time `json:"expiresAt"`
	Status     string    `json:"status"`
}

func (q *Queries) CreateWaitlistOffer(ctx context.Context, arg CreateWaitlistOfferParams) (WaitlistOffer, error) {
	row := q.queryRow(ctx, q.createWaitlistOfferStmt, createWaitlistOffer, arg.WaitlistID, arg.ExpiresAt, arg.Status)
	var i WaitlistOffer
	err := row.Scan(
		&i.ID,
		&i.WaitlistID,
		&i.OfferedAt,
		&i.ExpiresAt,
		&i.Status,
	)
	return i, err
}

const deletePastWaitlistEntries = `-- name: DeletePastWaitlistEntries :execrows
DELETE FROM waitlists
WHERE facility_id = ?1
  AND (
    target_date < CAST(?2 AS TEXT)
    OR (target_date = CAST(?2 AS TEXT) AND target_end_time < CAST(?3 AS TEXT))
  )
`

type DeletePastWaitlistEntriesParams struct {
	FacilityID     int64  `json:"facilityId"`
	ComparisonDate string `json:"comparisonDate"`
	ComparisonTime string `json:"comparisonTime"`
}

func (q *Queries) DeletePastWaitlistEntries(ctx context.Context, arg DeletePastWaitlistEntriesParams) (int64, error) {
	result, err := q.exec(ctx, q.deletePastWaitlistEntriesStmt, deletePastWaitlistEntries, arg.FacilityID, arg.ComparisonDate, arg.ComparisonTime)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const deleteWaitlistEntry = `-- name: DeleteWaitlistEntry :execrows
DELETE FROM waitlists
WHERE id = ?1
  AND facility_id = ?2
`

type DeleteWaitlistEntryParams struct {
	ID         int64 `json:"id"`
	FacilityID int64 `json:"facilityId"`
}

func (q *Queries) DeleteWaitlistEntry(ctx context.Context, arg DeleteWaitlistEntryParams) (int64, error) {
	result, err := q.exec(ctx, q.deleteWaitlistEntryStmt, deleteWaitlistEntry, arg.ID, arg.FacilityID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const expireOffer = `-- name: ExpireOffer :one
UPDATE waitlist_offers
SET status = 'expired'
WHERE id = ?1
  AND waitlist_id = ?2
RETURNING
    id,
    waitlist_id,
    offered_at,
    expires_at,
    status
`

type ExpireOfferParams struct {
	ID         int64 `json:"id"`
	WaitlistID int64 `json:"waitlistId"`
}

func (q *Queries) ExpireOffer(ctx context.Context, arg ExpireOfferParams) (WaitlistOffer, error) {
	row := q.queryRow(ctx, q.expireOfferStmt, expireOffer, arg.ID, arg.WaitlistID)
	var i WaitlistOffer
	err := row.Scan(
		&i.ID,
		&i.WaitlistID,
		&i.OfferedAt,
		&i.ExpiresAt,
		&i.Status,
	)
	return i, err
}

const getPendingOffer = `-- name: GetPendingOffer :one
SELECT
    id,
    waitlist_id,
    offered_at,
    expires_at,
    status
FROM waitlist_offers
WHERE waitlist_id = ?1
  AND status = 'pending'
ORDER BY offered_at DESC
LIMIT 1
`

func (q *Queries) GetPendingOffer(ctx context.Context, waitlistID int64) (WaitlistOffer, error) {
	row := q.queryRow(ctx, q.getPendingOfferStmt, getPendingOffer, waitlistID)
	var i WaitlistOffer
	err := row.Scan(
		&i.ID,
		&i.WaitlistID,
		&i.OfferedAt,
		&i.ExpiresAt,
		&i.Status,
	)
	return i, err
}

const getWaitlistConfig = `-- name: GetWaitlistConfig :one
SELECT
    id,
    facility_id,
    max_waitlist_size,
    notification_mode,
    offer_expiry_minutes,
    notification_window_minutes,
    created_at,
    updated_at
FROM waitlist_config
WHERE facility_id = ?1
LIMIT 1
`

func (q *Queries) GetWaitlistConfig(ctx context.Context, facilityID int64) (WaitlistConfig, error) {
	row := q.queryRow(ctx, q.getWaitlistConfigStmt, getWaitlistConfig, facilityID)
	var i WaitlistConfig
	err := row.Scan(
		&i.ID,
		&i.FacilityID,
		&i.MaxWaitlistSize,
		&i.NotificationMode,
		&i.OfferExpiryMinutes,
		&i.NotificationWindowMinutes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getWaitlistEntry = `-- name: GetWaitlistEntry :one
SELECT
    id,
    facility_id,
    user_id,
    target_court_id,
    target_date,
    target_start_time,
    target_end_time,
    position,
    status,
    created_at,
    updated_at
FROM waitlists
WHERE id = ?1
  AND facility_id = ?2
LIMIT 1
`

type GetWaitlistEntryParams struct {
	ID         int64 `json:"id"`
	FacilityID int64 `json:"facilityId"`
}

func (q *Queries) GetWaitlistEntry(ctx context.Context, arg GetWaitlistEntryParams) (Waitlist, error) {
	row := q.queryRow(ctx, q.getWaitlistEntryStmt, getWaitlistEntry, arg.ID, arg.FacilityID)
	var i Waitlist
	err := row.Scan(
		&i.ID,
		&i.FacilityID,
		&i.UserID,
		&i.TargetCourtID,
		&i.TargetDate,
		&i.TargetStartTime,
		&i.TargetEndTime,
		&i.Position,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listExpiredOffers = `-- name: ListExpiredOffers :many
SELECT
    wo.id AS offer_id,
    wo.waitlist_id,
    w.facility_id,
    wc.offer_expiry_minutes
FROM waitlist_offers wo
JOIN waitlists w ON w.id = wo.waitlist_id
JOIN waitlist_config wc ON wc.facility_id = w.facility_id
WHERE wo.status = 'pending'
  AND wo.expires_at < ?1
  AND w.status = 'notified'
  AND wc.notification_mode = 'sequential'
ORDER BY wo.expires_at
`

type ListExpiredOffersRow struct {
	OfferID            int64 `json:"offerId"`
	WaitlistID         int64 `json:"waitlistId"`
	FacilityID         int64 `json:"facilityId"`
	OfferExpiryMinutes int64 `json:"offerExpiryMinutes"`
}

func (q *Queries) ListExpiredOffers(ctx context.Context, comparisonTime time.Time) ([]ListExpiredOffersRow, error) {
	rows, err := q.query(ctx, q.listExpiredOffersStmt, listExpiredOffers, comparisonTime)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListExpiredOffersRow
	for rows.Next() {
		var i ListExpiredOffersRow
		if err := rows.Scan(
			&i.OfferID,
			&i.WaitlistID,
			&i.FacilityID,
			&i.OfferExpiryMinutes,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMatchingPendingWaitlistsForCancelledSlot = `-- name: ListMatchingPendingWaitlistsForCancelledSlot :many
SELECT
    id,
    facility_id,
    user_id,
    target_court_id,
    target_date,
    target_start_time,
    target_end_time,
    position,
    status,
    created_at,
    updated_at
FROM waitlists
WHERE facility_id = ?1
  AND target_date = ?2
  AND target_start_time = ?3
  AND target_end_time = ?4
  AND status = 'pending'
  AND (
      target_court_id = ?5
      OR (?5 IS NULL AND target_court_id IS NULL)
  )
ORDER BY position
`

type ListMatchingPendingWaitlistsForCancelledSlotParams struct {
	FacilityID      int64         `json:"facilityId"`
	TargetDate      time.Time     `json:"targetDate"`
	TargetStartTime interface{}   `json:"targetStartTime"`
	TargetEndTime   interface{}   `json:"targetEndTime"`
	TargetCourtID   sql.NullInt64 `json:"targetCourtId"`
}

func (q *Queries) ListMatchingPendingWaitlistsForCancelledSlot(ctx context.Context, arg ListMatchingPendingWaitlistsForCancelledSlotParams) ([]Waitlist, error) {
	rows, err := q.query(ctx, q.listMatchingPendingWaitlistsForCancelledSlotStmt, listMatchingPendingWaitlistsForCancelledSlot,
		arg.FacilityID,
		arg.TargetDate,
		arg.TargetStartTime,
		arg.TargetEndTime,
		arg.TargetCourtID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Waitlist
	for rows.Next() {
		var i Waitlist
		if err := rows.Scan(
			&i.ID,
			&i.FacilityID,
			&i.UserID,
			&i.TargetCourtID,
			&i.TargetDate,
			&i.TargetStartTime,
			&i.TargetEndTime,
			&i.Position,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listWaitlistsByFacility = `-- name: ListWaitlistsByFacility :many
SELECT
    id,
    facility_id,
    user_id,
    target_court_id,
    target_date,
    target_start_time,
    target_end_time,
    position,
    status,
    created_at,
    updated_at
FROM waitlists
WHERE facility_id = ?1
ORDER BY target_date, target_start_time, position
`

func (q *Queries) ListWaitlistsByFacility(ctx context.Context, facilityID int64) ([]Waitlist, error) {
	rows, err := q.query(ctx, q.listWaitlistsByFacilityStmt, listWaitlistsByFacility, facilityID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Waitlist
	for rows.Next() {
		var i Waitlist
		if err := rows.Scan(
			&i.ID,
			&i.FacilityID,
			&i.UserID,
			&i.TargetCourtID,
			&i.TargetDate,
			&i.TargetStartTime,
			&i.TargetEndTime,
			&i.Position,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listWaitlistsByUser = `-- name: ListWaitlistsByUser :many
SELECT
    id,
    facility_id,
    user_id,
    target_court_id,
    target_date,
    target_start_time,
    target_end_time,
    position,
    status,
    created_at,
    updated_at
FROM waitlists
WHERE user_id = ?1
ORDER BY created_at DESC
`

func (q *Queries) ListWaitlistsByUser(ctx context.Context, userID int64) ([]Waitlist, error) {
	rows, err := q.query(ctx, q.listWaitlistsByUserStmt, listWaitlistsByUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Waitlist
	for rows.Next() {
		var i Waitlist
		if err := rows.Scan(
			&i.ID,
			&i.FacilityID,
			&i.UserID,
			&i.TargetCourtID,
			&i.TargetDate,
			&i.TargetStartTime,
			&i.TargetEndTime,
			&i.Position,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listWaitlistsByUserAndFacility = `-- name: ListWaitlistsByUserAndFacility :many
SELECT
    id,
    facility_id,
    user_id,
    target_court_id,
    target_date,
    target_start_time,
    target_end_time,
    position,
    status,
    created_at,
    updated_at
FROM waitlists
WHERE user_id = ?1
  AND facility_id = ?2
ORDER BY created_at DESC
`

type ListWaitlistsByUserAndFacilityParams struct {
	UserID     int64 `json:"userId"`
	FacilityID int64 `json:"facilityId"`
}

func (q *Queries) ListWaitlistsByUserAndFacility(ctx context.Context, arg ListWaitlistsByUserAndFacilityParams) ([]Waitlist, error) {
	rows, err := q.query(ctx, q.listWaitlistsByUserAndFacilityStmt, listWaitlistsByUserAndFacility, arg.UserID, arg.FacilityID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Waitlist
	for rows.Next() {
		var i Waitlist
		if err := rows.Scan(
			&i.ID,
			&i.FacilityID,
			&i.UserID,
			&i.TargetCourtID,
			&i.TargetDate,
			&i.TargetStartTime,
			&i.TargetEndTime,
			&i.Position,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listWaitlistsForSlot = `-- name: ListWaitlistsForSlot :many
SELECT
    id,
    facility_id,
    user_id,
    target_court_id,
    target_date,
    target_start_time,
    target_end_time,
    position,
    status,
    created_at,
    updated_at
FROM waitlists
WHERE facility_id = ?1
  AND target_date = ?2
  AND target_start_time = ?3
  AND target_end_time = ?4
  AND (
      target_court_id = ?5
      OR (?5 IS NULL AND target_court_id IS NULL)
  )
ORDER BY position
`

type ListWaitlistsForSlotParams struct {
	FacilityID      int64         `json:"facilityId"`
	TargetDate      time.Time     `json:"targetDate"`
	TargetStartTime interface{}   `json:"targetStartTime"`
	TargetEndTime   interface{}   `json:"targetEndTime"`
	TargetCourtID   sql.NullInt64 `json:"targetCourtId"`
}

func (q *Queries) ListWaitlistsForSlot(ctx context.Context, arg ListWaitlistsForSlotParams) ([]Waitlist, error) {
	rows, err := q.query(ctx, q.listWaitlistsForSlotStmt, listWaitlistsForSlot,
		arg.FacilityID,
		arg.TargetDate,
		arg.TargetStartTime,
		arg.TargetEndTime,
		arg.TargetCourtID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Waitlist
	for rows.Next() {
		var i Waitlist
		if err := rows.Scan(
			&i.ID,
			&i.FacilityID,
			&i.UserID,
			&i.TargetCourtID,
			&i.TargetDate,
			&i.TargetStartTime,
			&i.TargetEndTime,
			&i.Position,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateWaitlistStatus = `-- name: UpdateWaitlistStatus :one
UPDATE waitlists
SET status = ?1,
    updated_at = CURRENT_TIMESTAMP
WHERE id = ?2
  AND facility_id = ?3
RETURNING
    id,
    facility_id,
    user_id,
    target_court_id,
    target_date,
    target_start_time,
    target_end_time,
    position,
    status,
    created_at,
    updated_at
`

type UpdateWaitlistStatusParams struct {
	Status     string `json:"status"`
	ID         int64  `json:"id"`
	FacilityID int64  `json:"facilityId"`
}

func (q *Queries) UpdateWaitlistStatus(ctx context.Context, arg UpdateWaitlistStatusParams) (Waitlist, error) {
	row := q.queryRow(ctx, q.updateWaitlistStatusStmt, updateWaitlistStatus, arg.Status, arg.ID, arg.FacilityID)
	var i Waitlist
	err := row.Scan(
		&i.ID,
		&i.FacilityID,
		&i.UserID,
		&i.TargetCourtID,
		&i.TargetDate,
		&i.TargetStartTime,
		&i.TargetEndTime,
		&i.Position,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const upsertWaitlistConfig = `-- name: UpsertWaitlistConfig :one
INSERT INTO waitlist_config (
    facility_id,
    max_waitlist_size,
    notification_mode,
    offer_expiry_minutes,
    notification_window_minutes
) VALUES (
    ?1,
    ?2,
    ?3,
    ?4,
    ?5
)
ON CONFLICT(facility_id) DO UPDATE SET
    max_waitlist_size = excluded.max_waitlist_size,
    notification_mode = excluded.notification_mode,
    offer_expiry_minutes = excluded.offer_expiry_minutes,
    notification_window_minutes = excluded.notification_window_minutes,
    updated_at = CURRENT_TIMESTAMP
RETURNING
    id,
    facility_id,
    max_waitlist_size,
    notification_mode,
    offer_expiry_minutes,
    notification_window_minutes,
    created_at,
    updated_at
`

type UpsertWaitlistConfigParams struct {
	FacilityID                int64  `json:"facilityId"`
	MaxWaitlistSize           int64  `json:"maxWaitlistSize"`
	NotificationMode          string `json:"notificationMode"`
	OfferExpiryMinutes        int64  `json:"offerExpiryMinutes"`
	NotificationWindowMinutes int64  `json:"notificationWindowMinutes"`
}

func (q *Queries) UpsertWaitlistConfig(ctx context.Context, arg UpsertWaitlistConfigParams) (WaitlistConfig, error) {
	row := q.queryRow(ctx, q.upsertWaitlistConfigStmt, upsertWaitlistConfig,
		arg.FacilityID,
		arg.MaxWaitlistSize,
		arg.NotificationMode,
		arg.OfferExpiryMinutes,
		arg.NotificationWindowMinutes,
	)
	var i WaitlistConfig
	err := row.Scan(
		&i.ID,
		&i.FacilityID,
		&i.MaxWaitlistSize,
		&i.NotificationMode,
		&i.OfferExpiryMinutes,
		&i.NotificationWindowMinutes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

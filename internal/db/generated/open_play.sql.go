// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: open_play.sql

package db

import (
	"context"
)

const createOpenPlayRule = `-- name: CreateOpenPlayRule :one
INSERT INTO open_play_rules (
    facility_id,
    name,
    min_participants,
    max_participants_per_court,
    cancellation_cutoff_minutes,
    auto_scale_enabled,
    min_courts,
    max_courts
) VALUES (
    ?1,
    ?2,
    ?3,
    ?4,
    ?5,
    ?6,
    ?7,
    ?8
)
RETURNING id, facility_id, name, min_participants, max_participants_per_court,
    cancellation_cutoff_minutes, auto_scale_enabled, min_courts, max_courts,
    created_at, updated_at
`

type CreateOpenPlayRuleParams struct {
	FacilityID                int64  `json:"facilityId"`
	Name                      string `json:"name"`
	MinParticipants           int64  `json:"minParticipants"`
	MaxParticipantsPerCourt   int64  `json:"maxParticipantsPerCourt"`
	CancellationCutoffMinutes int64  `json:"cancellationCutoffMinutes"`
	AutoScaleEnabled          bool   `json:"autoScaleEnabled"`
	MinCourts                 int64  `json:"minCourts"`
	MaxCourts                 int64  `json:"maxCourts"`
}

func (q *Queries) CreateOpenPlayRule(ctx context.Context, arg CreateOpenPlayRuleParams) (OpenPlayRule, error) {
	row := q.queryRow(ctx, q.createOpenPlayRuleStmt, createOpenPlayRule,
		arg.FacilityID,
		arg.Name,
		arg.MinParticipants,
		arg.MaxParticipantsPerCourt,
		arg.CancellationCutoffMinutes,
		arg.AutoScaleEnabled,
		arg.MinCourts,
		arg.MaxCourts,
	)
	var i OpenPlayRule
	err := row.Scan(
		&i.ID,
		&i.FacilityID,
		&i.Name,
		&i.MinParticipants,
		&i.MaxParticipantsPerCourt,
		&i.CancellationCutoffMinutes,
		&i.AutoScaleEnabled,
		&i.MinCourts,
		&i.MaxCourts,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteOpenPlayRule = `-- name: DeleteOpenPlayRule :execrows
DELETE FROM open_play_rules
WHERE id = ?1
  AND facility_id = ?2
`

type DeleteOpenPlayRuleParams struct {
	ID         int64 `json:"id"`
	FacilityID int64 `json:"facilityId"`
}

func (q *Queries) DeleteOpenPlayRule(ctx context.Context, arg DeleteOpenPlayRuleParams) (int64, error) {
	result, err := q.exec(ctx, q.deleteOpenPlayRuleStmt, deleteOpenPlayRule, arg.ID, arg.FacilityID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const getOpenPlayRule = `-- name: GetOpenPlayRule :one
SELECT id, facility_id, name, min_participants, max_participants_per_court,
    cancellation_cutoff_minutes, auto_scale_enabled, min_courts, max_courts,
    created_at, updated_at
FROM open_play_rules
WHERE id = ?1
  AND facility_id = ?2
`

type GetOpenPlayRuleParams struct {
	ID         int64 `json:"id"`
	FacilityID int64 `json:"facilityId"`
}

func (q *Queries) GetOpenPlayRule(ctx context.Context, arg GetOpenPlayRuleParams) (OpenPlayRule, error) {
	row := q.queryRow(ctx, q.getOpenPlayRuleStmt, getOpenPlayRule, arg.ID, arg.FacilityID)
	var i OpenPlayRule
	err := row.Scan(
		&i.ID,
		&i.FacilityID,
		&i.Name,
		&i.MinParticipants,
		&i.MaxParticipantsPerCourt,
		&i.CancellationCutoffMinutes,
		&i.AutoScaleEnabled,
		&i.MinCourts,
		&i.MaxCourts,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listOpenPlayRules = `-- name: ListOpenPlayRules :many
SELECT id, facility_id, name, min_participants, max_participants_per_court,
    cancellation_cutoff_minutes, auto_scale_enabled, min_courts, max_courts,
    created_at, updated_at
FROM open_play_rules
WHERE facility_id = ?1
ORDER BY name
`

func (q *Queries) ListOpenPlayRules(ctx context.Context, facilityID int64) ([]OpenPlayRule, error) {
	rows, err := q.query(ctx, q.listOpenPlayRulesStmt, listOpenPlayRules, facilityID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []OpenPlayRule
	for rows.Next() {
		var i OpenPlayRule
		if err := rows.Scan(
			&i.ID,
			&i.FacilityID,
			&i.Name,
			&i.MinParticipants,
			&i.MaxParticipantsPerCourt,
			&i.CancellationCutoffMinutes,
			&i.AutoScaleEnabled,
			&i.MinCourts,
			&i.MaxCourts,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateOpenPlayRule = `-- name: UpdateOpenPlayRule :one
UPDATE open_play_rules
SET name = ?1,
    min_participants = ?2,
    max_participants_per_court = ?3,
    cancellation_cutoff_minutes = ?4,
    auto_scale_enabled = ?5,
    min_courts = ?6,
    max_courts = ?7,
    updated_at = CURRENT_TIMESTAMP
WHERE id = ?8
  AND facility_id = ?9
RETURNING id, facility_id, name, min_participants, max_participants_per_court,
    cancellation_cutoff_minutes, auto_scale_enabled, min_courts, max_courts,
    created_at, updated_at
`

type UpdateOpenPlayRuleParams struct {
	Name                      string `json:"name"`
	MinParticipants           int64  `json:"minParticipants"`
	MaxParticipantsPerCourt   int64  `json:"maxParticipantsPerCourt"`
	CancellationCutoffMinutes int64  `json:"cancellationCutoffMinutes"`
	AutoScaleEnabled          bool   `json:"autoScaleEnabled"`
	MinCourts                 int64  `json:"minCourts"`
	MaxCourts                 int64  `json:"maxCourts"`
	ID                        int64  `json:"id"`
	FacilityID                int64  `json:"facilityId"`
}

func (q *Queries) UpdateOpenPlayRule(ctx context.Context, arg UpdateOpenPlayRuleParams) (OpenPlayRule, error) {
	row := q.queryRow(ctx, q.updateOpenPlayRuleStmt, updateOpenPlayRule,
		arg.Name,
		arg.MinParticipants,
		arg.MaxParticipantsPerCourt,
		arg.CancellationCutoffMinutes,
		arg.AutoScaleEnabled,
		arg.MinCourts,
		arg.MaxCourts,
		arg.ID,
		arg.FacilityID,
	)
	var i OpenPlayRule
	err := row.Scan(
		&i.ID,
		&i.FacilityID,
		&i.Name,
		&i.MinParticipants,
		&i.MaxParticipantsPerCourt,
		&i.CancellationCutoffMinutes,
		&i.AutoScaleEnabled,
		&i.MinCourts,
		&i.MaxCourts,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

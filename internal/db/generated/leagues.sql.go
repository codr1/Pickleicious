// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: leagues.sql

package db

import (
	"context"
	"database/sql"
	"time"
)

const addTeamMember = `-- name: AddTeamMember :one
INSERT INTO league_team_members (
    league_team_id,
    user_id,
    is_free_agent
) VALUES (
    ?1,
    ?2,
    ?3
)
RETURNING id, league_team_id, user_id, is_free_agent, created_at
`

type AddTeamMemberParams struct {
	LeagueTeamID int64 `json:"leagueTeamId"`
	UserID       int64 `json:"userId"`
	IsFreeAgent  bool  `json:"isFreeAgent"`
}

func (q *Queries) AddTeamMember(ctx context.Context, arg AddTeamMemberParams) (LeagueTeamMember, error) {
	row := q.queryRow(ctx, q.addTeamMemberStmt, addTeamMember, arg.LeagueTeamID, arg.UserID, arg.IsFreeAgent)
	var i LeagueTeamMember
	err := row.Scan(
		&i.ID,
		&i.LeagueTeamID,
		&i.UserID,
		&i.IsFreeAgent,
		&i.CreatedAt,
	)
	return i, err
}

const assignFreeAgentToTeam = `-- name: AssignFreeAgentToTeam :one
UPDATE league_team_members
SET league_team_id = ?1,
    is_free_agent = 0
WHERE user_id = ?2
  AND is_free_agent = 1
  AND league_team_id IN (
    SELECT id FROM league_teams WHERE league_teams.league_id = ?3
  )
  AND EXISTS (
    SELECT 1 FROM league_teams lt WHERE lt.id = ?1 AND lt.league_id = ?3
  )
RETURNING id, league_team_id, user_id, is_free_agent, created_at
`

type AssignFreeAgentToTeamParams struct {
	LeagueTeamID int64 `json:"leagueTeamId"`
	UserID       int64 `json:"userId"`
	LeagueID     int64 `json:"leagueId"`
}

func (q *Queries) AssignFreeAgentToTeam(ctx context.Context, arg AssignFreeAgentToTeamParams) (LeagueTeamMember, error) {
	row := q.queryRow(ctx, q.assignFreeAgentToTeamStmt, assignFreeAgentToTeam, arg.LeagueTeamID, arg.UserID, arg.LeagueID)
	var i LeagueTeamMember
	err := row.Scan(
		&i.ID,
		&i.LeagueTeamID,
		&i.UserID,
		&i.IsFreeAgent,
		&i.CreatedAt,
	)
	return i, err
}

const createLeague = `-- name: CreateLeague :one

INSERT INTO leagues (
    facility_id,
    name,
    format,
    start_date,
    end_date,
    division_config,
    min_team_size,
    max_team_size,
    roster_lock_date,
    status
) VALUES (
    ?1,
    ?2,
    ?3,
    ?4,
    ?5,
    ?6,
    ?7,
    ?8,
    ?9,
    ?10
)
RETURNING id, facility_id, name, format, start_date, end_date, division_config,
    min_team_size, max_team_size, roster_lock_date, status, created_at, updated_at
`

type CreateLeagueParams struct {
	FacilityID     int64        `json:"facilityId"`
	Name           string       `json:"name"`
	Format         string       `json:"format"`
	StartDate      time.Time    `json:"startDate"`
	EndDate        time.Time    `json:"endDate"`
	DivisionConfig string       `json:"divisionConfig"`
	MinTeamSize    int64        `json:"minTeamSize"`
	MaxTeamSize    int64        `json:"maxTeamSize"`
	RosterLockDate sql.NullTime `json:"rosterLockDate"`
	Status         string       `json:"status"`
}

// internal/db/queries/leagues.sql
func (q *Queries) CreateLeague(ctx context.Context, arg CreateLeagueParams) (League, error) {
	row := q.queryRow(ctx, q.createLeagueStmt, createLeague,
		arg.FacilityID,
		arg.Name,
		arg.Format,
		arg.StartDate,
		arg.EndDate,
		arg.DivisionConfig,
		arg.MinTeamSize,
		arg.MaxTeamSize,
		arg.RosterLockDate,
		arg.Status,
	)
	var i League
	err := row.Scan(
		&i.ID,
		&i.FacilityID,
		&i.Name,
		&i.Format,
		&i.StartDate,
		&i.EndDate,
		&i.DivisionConfig,
		&i.MinTeamSize,
		&i.MaxTeamSize,
		&i.RosterLockDate,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createLeagueMatch = `-- name: CreateLeagueMatch :one
INSERT INTO league_matches (
    league_id,
    home_team_id,
    away_team_id,
    reservation_id,
    scheduled_time,
    home_score,
    away_score,
    status
) VALUES (
    ?1,
    ?2,
    ?3,
    ?4,
    ?5,
    ?6,
    ?7,
    ?8
)
RETURNING id, league_id, home_team_id, away_team_id, reservation_id,
    scheduled_time, home_score, away_score, status, created_at, updated_at
`

type CreateLeagueMatchParams struct {
	LeagueID      int64         `json:"leagueId"`
	HomeTeamID    int64         `json:"homeTeamId"`
	AwayTeamID    int64         `json:"awayTeamId"`
	ReservationID sql.NullInt64 `json:"reservationId"`
	ScheduledTime time.Time     `json:"scheduledTime"`
	HomeScore     sql.NullInt64 `json:"homeScore"`
	AwayScore     sql.NullInt64 `json:"awayScore"`
	Status        string        `json:"status"`
}

func (q *Queries) CreateLeagueMatch(ctx context.Context, arg CreateLeagueMatchParams) (LeagueMatch, error) {
	row := q.queryRow(ctx, q.createLeagueMatchStmt, createLeagueMatch,
		arg.LeagueID,
		arg.HomeTeamID,
		arg.AwayTeamID,
		arg.ReservationID,
		arg.ScheduledTime,
		arg.HomeScore,
		arg.AwayScore,
		arg.Status,
	)
	var i LeagueMatch
	err := row.Scan(
		&i.ID,
		&i.LeagueID,
		&i.HomeTeamID,
		&i.AwayTeamID,
		&i.ReservationID,
		&i.ScheduledTime,
		&i.HomeScore,
		&i.AwayScore,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createLeagueTeam = `-- name: CreateLeagueTeam :one
INSERT INTO league_teams (
    league_id,
    name,
    captain_user_id,
    status
) VALUES (
    ?1,
    ?2,
    ?3,
    ?4
)
RETURNING id, league_id, name, captain_user_id, status, created_at, updated_at
`

type CreateLeagueTeamParams struct {
	LeagueID      int64  `json:"leagueId"`
	Name          string `json:"name"`
	CaptainUserID int64  `json:"captainUserId"`
	Status        string `json:"status"`
}

func (q *Queries) CreateLeagueTeam(ctx context.Context, arg CreateLeagueTeamParams) (LeagueTeam, error) {
	row := q.queryRow(ctx, q.createLeagueTeamStmt, createLeagueTeam,
		arg.LeagueID,
		arg.Name,
		arg.CaptainUserID,
		arg.Status,
	)
	var i LeagueTeam
	err := row.Scan(
		&i.ID,
		&i.LeagueID,
		&i.Name,
		&i.CaptainUserID,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteLeague = `-- name: DeleteLeague :execrows
DELETE FROM leagues
WHERE id = ?1
`

func (q *Queries) DeleteLeague(ctx context.Context, id int64) (int64, error) {
	result, err := q.exec(ctx, q.deleteLeagueStmt, deleteLeague, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const deleteLeagueMatchesByLeagueID = `-- name: DeleteLeagueMatchesByLeagueID :execrows
DELETE FROM league_matches
WHERE league_id = ?1
`

func (q *Queries) DeleteLeagueMatchesByLeagueID(ctx context.Context, leagueID int64) (int64, error) {
	result, err := q.exec(ctx, q.deleteLeagueMatchesByLeagueIDStmt, deleteLeagueMatchesByLeagueID, leagueID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const getLeague = `-- name: GetLeague :one
SELECT id, facility_id, name, format, start_date, end_date, division_config,
    min_team_size, max_team_size, roster_lock_date, status, created_at, updated_at
FROM leagues
WHERE id = ?1
`

func (q *Queries) GetLeague(ctx context.Context, id int64) (League, error) {
	row := q.queryRow(ctx, q.getLeagueStmt, getLeague, id)
	var i League
	err := row.Scan(
		&i.ID,
		&i.FacilityID,
		&i.Name,
		&i.Format,
		&i.StartDate,
		&i.EndDate,
		&i.DivisionConfig,
		&i.MinTeamSize,
		&i.MaxTeamSize,
		&i.RosterLockDate,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getLeagueMatch = `-- name: GetLeagueMatch :one
SELECT id, league_id, home_team_id, away_team_id, reservation_id,
    scheduled_time, home_score, away_score, status, created_at, updated_at
FROM league_matches
WHERE id = ?1
  AND league_id = ?2
`

type GetLeagueMatchParams struct {
	ID       int64 `json:"id"`
	LeagueID int64 `json:"leagueId"`
}

func (q *Queries) GetLeagueMatch(ctx context.Context, arg GetLeagueMatchParams) (LeagueMatch, error) {
	row := q.queryRow(ctx, q.getLeagueMatchStmt, getLeagueMatch, arg.ID, arg.LeagueID)
	var i LeagueMatch
	err := row.Scan(
		&i.ID,
		&i.LeagueID,
		&i.HomeTeamID,
		&i.AwayTeamID,
		&i.ReservationID,
		&i.ScheduledTime,
		&i.HomeScore,
		&i.AwayScore,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getLeagueStandingsData = `-- name: GetLeagueStandingsData :many
SELECT lt.id AS team_id,
    lt.name AS team_name,
    lm.id AS match_id,
    lm.home_team_id,
    lm.away_team_id,
    lm.home_score,
    lm.away_score
FROM league_teams lt
LEFT JOIN league_matches lm
    ON lm.league_id = lt.league_id
    AND lm.status = 'completed'
    AND (lm.home_team_id = lt.id OR lm.away_team_id = lt.id)
WHERE lt.league_id = ?1
ORDER BY lt.name, lm.scheduled_time
`

type GetLeagueStandingsDataRow struct {
	TeamID     int64         `json:"teamId"`
	TeamName   string        `json:"teamName"`
	MatchID    sql.NullInt64 `json:"matchId"`
	HomeTeamID sql.NullInt64 `json:"homeTeamId"`
	AwayTeamID sql.NullInt64 `json:"awayTeamId"`
	HomeScore  sql.NullInt64 `json:"homeScore"`
	AwayScore  sql.NullInt64 `json:"awayScore"`
}

func (q *Queries) GetLeagueStandingsData(ctx context.Context, leagueID int64) ([]GetLeagueStandingsDataRow, error) {
	rows, err := q.query(ctx, q.getLeagueStandingsDataStmt, getLeagueStandingsData, leagueID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetLeagueStandingsDataRow
	for rows.Next() {
		var i GetLeagueStandingsDataRow
		if err := rows.Scan(
			&i.TeamID,
			&i.TeamName,
			&i.MatchID,
			&i.HomeTeamID,
			&i.AwayTeamID,
			&i.HomeScore,
			&i.AwayScore,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLeagueTeam = `-- name: GetLeagueTeam :one
SELECT id, league_id, name, captain_user_id, status, created_at, updated_at
FROM league_teams
WHERE id = ?1
`

func (q *Queries) GetLeagueTeam(ctx context.Context, id int64) (LeagueTeam, error) {
	row := q.queryRow(ctx, q.getLeagueTeamStmt, getLeagueTeam, id)
	var i LeagueTeam
	err := row.Scan(
		&i.ID,
		&i.LeagueID,
		&i.Name,
		&i.CaptainUserID,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listFreeAgentsByLeague = `-- name: ListFreeAgentsByLeague :many
SELECT ltm.id,
    ltm.league_team_id,
    ltm.user_id,
    u.first_name,
    u.last_name,
    u.photo_url,
    ltm.created_at
FROM league_team_members ltm
JOIN league_teams lt ON lt.id = ltm.league_team_id
JOIN users u ON u.id = ltm.user_id
WHERE lt.league_id = ?1
  AND ltm.is_free_agent = 1
ORDER BY u.last_name, u.first_name
`

type ListFreeAgentsByLeagueRow struct {
	ID           int64          `json:"id"`
	LeagueTeamID int64          `json:"leagueTeamId"`
	UserID       int64          `json:"userId"`
	FirstName    string         `json:"firstName"`
	LastName     string         `json:"lastName"`
	PhotoUrl     sql.NullString `json:"photoUrl"`
	CreatedAt    time.Time      `json:"createdAt"`
}

func (q *Queries) ListFreeAgentsByLeague(ctx context.Context, leagueID int64) ([]ListFreeAgentsByLeagueRow, error) {
	rows, err := q.query(ctx, q.listFreeAgentsByLeagueStmt, listFreeAgentsByLeague, leagueID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListFreeAgentsByLeagueRow
	for rows.Next() {
		var i ListFreeAgentsByLeagueRow
		if err := rows.Scan(
			&i.ID,
			&i.LeagueTeamID,
			&i.UserID,
			&i.FirstName,
			&i.LastName,
			&i.PhotoUrl,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listLeagueMatches = `-- name: ListLeagueMatches :many
SELECT id, league_id, home_team_id, away_team_id, reservation_id,
    scheduled_time, home_score, away_score, status, created_at, updated_at
FROM league_matches
WHERE league_id = ?1
ORDER BY scheduled_time
`

func (q *Queries) ListLeagueMatches(ctx context.Context, leagueID int64) ([]LeagueMatch, error) {
	rows, err := q.query(ctx, q.listLeagueMatchesStmt, listLeagueMatches, leagueID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []LeagueMatch
	for rows.Next() {
		var i LeagueMatch
		if err := rows.Scan(
			&i.ID,
			&i.LeagueID,
			&i.HomeTeamID,
			&i.AwayTeamID,
			&i.ReservationID,
			&i.ScheduledTime,
			&i.HomeScore,
			&i.AwayScore,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listLeagueMatchesWithReservations = `-- name: ListLeagueMatchesWithReservations :many
SELECT lm.id,
    lm.league_id,
    lm.home_team_id,
    lm.away_team_id,
    lm.reservation_id,
    lm.scheduled_time,
    lm.home_score,
    lm.away_score,
    lm.status,
    lm.created_at,
    lm.updated_at,
    r.start_time,
    r.end_time,
    CASE
        WHEN COUNT(rc.court_id) = 0 THEN NULL
        ELSE MIN(rc.court_id)
    END AS court_id
FROM league_matches lm
LEFT JOIN reservations r ON r.id = lm.reservation_id
LEFT JOIN reservation_courts rc ON rc.reservation_id = r.id
WHERE lm.league_id = ?1
GROUP BY lm.id,
    lm.league_id,
    lm.home_team_id,
    lm.away_team_id,
    lm.reservation_id,
    lm.scheduled_time,
    lm.home_score,
    lm.away_score,
    lm.status,
    lm.created_at,
    lm.updated_at,
    r.start_time,
    r.end_time
ORDER BY lm.scheduled_time
`

type ListLeagueMatchesWithReservationsRow struct {
	ID            int64         `json:"id"`
	LeagueID      int64         `json:"leagueId"`
	HomeTeamID    int64         `json:"homeTeamId"`
	AwayTeamID    int64         `json:"awayTeamId"`
	ReservationID sql.NullInt64 `json:"reservationId"`
	ScheduledTime time.Time     `json:"scheduledTime"`
	HomeScore     sql.NullInt64 `json:"homeScore"`
	AwayScore     sql.NullInt64 `json:"awayScore"`
	Status        string        `json:"status"`
	CreatedAt     time.Time     `json:"createdAt"`
	UpdatedAt     time.Time     `json:"updatedAt"`
	StartTime     sql.NullTime  `json:"startTime"`
	EndTime       sql.NullTime  `json:"endTime"`
	CourtID       interface{}   `json:"courtId"`
}

func (q *Queries) ListLeagueMatchesWithReservations(ctx context.Context, leagueID int64) ([]ListLeagueMatchesWithReservationsRow, error) {
	rows, err := q.query(ctx, q.listLeagueMatchesWithReservationsStmt, listLeagueMatchesWithReservations, leagueID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListLeagueMatchesWithReservationsRow
	for rows.Next() {
		var i ListLeagueMatchesWithReservationsRow
		if err := rows.Scan(
			&i.ID,
			&i.LeagueID,
			&i.HomeTeamID,
			&i.AwayTeamID,
			&i.ReservationID,
			&i.ScheduledTime,
			&i.HomeScore,
			&i.AwayScore,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.StartTime,
			&i.EndTime,
			&i.CourtID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listLeagueTeams = `-- name: ListLeagueTeams :many
SELECT id, league_id, name, captain_user_id, status, created_at, updated_at
FROM league_teams
WHERE league_id = ?1
ORDER BY name
`

func (q *Queries) ListLeagueTeams(ctx context.Context, leagueID int64) ([]LeagueTeam, error) {
	rows, err := q.query(ctx, q.listLeagueTeamsStmt, listLeagueTeams, leagueID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []LeagueTeam
	for rows.Next() {
		var i LeagueTeam
		if err := rows.Scan(
			&i.ID,
			&i.LeagueID,
			&i.Name,
			&i.CaptainUserID,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listLeaguesByFacility = `-- name: ListLeaguesByFacility :many
SELECT id, facility_id, name, format, start_date, end_date, division_config,
    min_team_size, max_team_size, roster_lock_date, status, created_at, updated_at
FROM leagues
WHERE facility_id = ?1
ORDER BY start_date DESC, name
`

func (q *Queries) ListLeaguesByFacility(ctx context.Context, facilityID int64) ([]League, error) {
	rows, err := q.query(ctx, q.listLeaguesByFacilityStmt, listLeaguesByFacility, facilityID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []League
	for rows.Next() {
		var i League
		if err := rows.Scan(
			&i.ID,
			&i.FacilityID,
			&i.Name,
			&i.Format,
			&i.StartDate,
			&i.EndDate,
			&i.DivisionConfig,
			&i.MinTeamSize,
			&i.MaxTeamSize,
			&i.RosterLockDate,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTeamMembers = `-- name: ListTeamMembers :many
SELECT id, league_team_id, user_id, is_free_agent, created_at
FROM league_team_members
WHERE league_team_id = ?1
ORDER BY created_at
`

func (q *Queries) ListTeamMembers(ctx context.Context, leagueTeamID int64) ([]LeagueTeamMember, error) {
	rows, err := q.query(ctx, q.listTeamMembersStmt, listTeamMembers, leagueTeamID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []LeagueTeamMember
	for rows.Next() {
		var i LeagueTeamMember
		if err := rows.Scan(
			&i.ID,
			&i.LeagueTeamID,
			&i.UserID,
			&i.IsFreeAgent,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeTeamMember = `-- name: RemoveTeamMember :execrows
DELETE FROM league_team_members
WHERE league_team_id = ?1
  AND user_id = ?2
`

type RemoveTeamMemberParams struct {
	LeagueTeamID int64 `json:"leagueTeamId"`
	UserID       int64 `json:"userId"`
}

func (q *Queries) RemoveTeamMember(ctx context.Context, arg RemoveTeamMemberParams) (int64, error) {
	result, err := q.exec(ctx, q.removeTeamMemberStmt, removeTeamMember, arg.LeagueTeamID, arg.UserID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const updateLeague = `-- name: UpdateLeague :one
UPDATE leagues
SET name = ?1,
    format = ?2,
    start_date = ?3,
    end_date = ?4,
    division_config = ?5,
    min_team_size = ?6,
    max_team_size = ?7,
    roster_lock_date = ?8,
    status = ?9,
    updated_at = CURRENT_TIMESTAMP
WHERE id = ?10
RETURNING id, facility_id, name, format, start_date, end_date, division_config,
    min_team_size, max_team_size, roster_lock_date, status, created_at, updated_at
`

type UpdateLeagueParams struct {
	Name           string       `json:"name"`
	Format         string       `json:"format"`
	StartDate      time.Time    `json:"startDate"`
	EndDate        time.Time    `json:"endDate"`
	DivisionConfig string       `json:"divisionConfig"`
	MinTeamSize    int64        `json:"minTeamSize"`
	MaxTeamSize    int64        `json:"maxTeamSize"`
	RosterLockDate sql.NullTime `json:"rosterLockDate"`
	Status         string       `json:"status"`
	ID             int64        `json:"id"`
}

func (q *Queries) UpdateLeague(ctx context.Context, arg UpdateLeagueParams) (League, error) {
	row := q.queryRow(ctx, q.updateLeagueStmt, updateLeague,
		arg.Name,
		arg.Format,
		arg.StartDate,
		arg.EndDate,
		arg.DivisionConfig,
		arg.MinTeamSize,
		arg.MaxTeamSize,
		arg.RosterLockDate,
		arg.Status,
		arg.ID,
	)
	var i League
	err := row.Scan(
		&i.ID,
		&i.FacilityID,
		&i.Name,
		&i.Format,
		&i.StartDate,
		&i.EndDate,
		&i.DivisionConfig,
		&i.MinTeamSize,
		&i.MaxTeamSize,
		&i.RosterLockDate,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateLeagueTeam = `-- name: UpdateLeagueTeam :one
UPDATE league_teams
SET name = ?1,
    status = ?2,
    updated_at = CURRENT_TIMESTAMP
WHERE id = ?3
  AND league_id = ?4
RETURNING id, league_id, name, captain_user_id, status, created_at, updated_at
`

type UpdateLeagueTeamParams struct {
	Name     string `json:"name"`
	Status   string `json:"status"`
	ID       int64  `json:"id"`
	LeagueID int64  `json:"leagueId"`
}

func (q *Queries) UpdateLeagueTeam(ctx context.Context, arg UpdateLeagueTeamParams) (LeagueTeam, error) {
	row := q.queryRow(ctx, q.updateLeagueTeamStmt, updateLeagueTeam,
		arg.Name,
		arg.Status,
		arg.ID,
		arg.LeagueID,
	)
	var i LeagueTeam
	err := row.Scan(
		&i.ID,
		&i.LeagueID,
		&i.Name,
		&i.CaptainUserID,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateMatchResult = `-- name: UpdateMatchResult :one
UPDATE league_matches
SET home_score = ?1,
    away_score = ?2,
    status = ?3,
    updated_at = CURRENT_TIMESTAMP
WHERE id = ?4
  AND league_id = ?5
RETURNING id, league_id, home_team_id, away_team_id, reservation_id,
    scheduled_time, home_score, away_score, status, created_at, updated_at
`

type UpdateMatchResultParams struct {
	HomeScore sql.NullInt64 `json:"homeScore"`
	AwayScore sql.NullInt64 `json:"awayScore"`
	Status    string        `json:"status"`
	ID        int64         `json:"id"`
	LeagueID  int64         `json:"leagueId"`
}

func (q *Queries) UpdateMatchResult(ctx context.Context, arg UpdateMatchResultParams) (LeagueMatch, error) {
	row := q.queryRow(ctx, q.updateMatchResultStmt, updateMatchResult,
		arg.HomeScore,
		arg.AwayScore,
		arg.Status,
		arg.ID,
		arg.LeagueID,
	)
	var i LeagueMatch
	err := row.Scan(
		&i.ID,
		&i.LeagueID,
		&i.HomeTeamID,
		&i.AwayTeamID,
		&i.ReservationID,
		&i.ScheduledTime,
		&i.HomeScore,
		&i.AwayScore,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateTeamCaptain = `-- name: UpdateTeamCaptain :one
UPDATE league_teams
SET captain_user_id = ?1,
    updated_at = CURRENT_TIMESTAMP
WHERE id = ?2
  AND league_id = ?3
RETURNING id, league_id, name, captain_user_id, status, created_at, updated_at
`

type UpdateTeamCaptainParams struct {
	CaptainUserID int64 `json:"captainUserId"`
	ID            int64 `json:"id"`
	LeagueID      int64 `json:"leagueId"`
}

func (q *Queries) UpdateTeamCaptain(ctx context.Context, arg UpdateTeamCaptainParams) (LeagueTeam, error) {
	row := q.queryRow(ctx, q.updateTeamCaptainStmt, updateTeamCaptain, arg.CaptainUserID, arg.ID, arg.LeagueID)
	var i LeagueTeam
	err := row.Scan(
		&i.ID,
		&i.LeagueID,
		&i.Name,
		&i.CaptainUserID,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

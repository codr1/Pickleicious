// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: leagues.sql

package db

import (
	"context"
	"database/sql"
	"time"
)

const addTeamMember = `-- name: AddTeamMember :one
INSERT INTO league_team_members (
    league_team_id,
    user_id,
    is_free_agent
) VALUES (
    ?1,
    ?2,
    ?3
)
RETURNING id, league_team_id, user_id, is_free_agent, created_at
`

type AddTeamMemberParams struct {
	LeagueTeamID int64 `json:"leagueTeamId"`
	UserID       int64 `json:"userId"`
	IsFreeAgent  bool  `json:"isFreeAgent"`
}

func (q *Queries) AddTeamMember(ctx context.Context, arg AddTeamMemberParams) (LeagueTeamMember, error) {
	row := q.queryRow(ctx, q.addTeamMemberStmt, addTeamMember, arg.LeagueTeamID, arg.UserID, arg.IsFreeAgent)
	var i LeagueTeamMember
	err := row.Scan(
		&i.ID,
		&i.LeagueTeamID,
		&i.UserID,
		&i.IsFreeAgent,
		&i.CreatedAt,
	)
	return i, err
}

const createLeague = `-- name: CreateLeague :one

INSERT INTO leagues (
    facility_id,
    name,
    format,
    start_date,
    end_date,
    division_config,
    min_team_size,
    max_team_size,
    roster_lock_date,
    status
) VALUES (
    ?1,
    ?2,
    ?3,
    ?4,
    ?5,
    ?6,
    ?7,
    ?8,
    ?9,
    ?10
)
RETURNING id, facility_id, name, format, start_date, end_date, division_config,
    min_team_size, max_team_size, roster_lock_date, status, created_at, updated_at
`

type CreateLeagueParams struct {
	FacilityID     int64        `json:"facilityId"`
	Name           string       `json:"name"`
	Format         string       `json:"format"`
	StartDate      time.Time    `json:"startDate"`
	EndDate        time.Time    `json:"endDate"`
	DivisionConfig string       `json:"divisionConfig"`
	MinTeamSize    int64        `json:"minTeamSize"`
	MaxTeamSize    int64        `json:"maxTeamSize"`
	RosterLockDate sql.NullTime `json:"rosterLockDate"`
	Status         string       `json:"status"`
}

// internal/db/queries/leagues.sql
func (q *Queries) CreateLeague(ctx context.Context, arg CreateLeagueParams) (League, error) {
	row := q.queryRow(ctx, q.createLeagueStmt, createLeague,
		arg.FacilityID,
		arg.Name,
		arg.Format,
		arg.StartDate,
		arg.EndDate,
		arg.DivisionConfig,
		arg.MinTeamSize,
		arg.MaxTeamSize,
		arg.RosterLockDate,
		arg.Status,
	)
	var i League
	err := row.Scan(
		&i.ID,
		&i.FacilityID,
		&i.Name,
		&i.Format,
		&i.StartDate,
		&i.EndDate,
		&i.DivisionConfig,
		&i.MinTeamSize,
		&i.MaxTeamSize,
		&i.RosterLockDate,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createLeagueMatch = `-- name: CreateLeagueMatch :one
INSERT INTO league_matches (
    league_id,
    home_team_id,
    away_team_id,
    reservation_id,
    scheduled_time,
    home_score,
    away_score,
    status
) VALUES (
    ?1,
    ?2,
    ?3,
    ?4,
    ?5,
    ?6,
    ?7,
    ?8
)
RETURNING id, league_id, home_team_id, away_team_id, reservation_id,
    scheduled_time, home_score, away_score, status, created_at, updated_at
`

type CreateLeagueMatchParams struct {
	LeagueID      int64         `json:"leagueId"`
	HomeTeamID    int64         `json:"homeTeamId"`
	AwayTeamID    int64         `json:"awayTeamId"`
	ReservationID sql.NullInt64 `json:"reservationId"`
	ScheduledTime time.Time     `json:"scheduledTime"`
	HomeScore     sql.NullInt64 `json:"homeScore"`
	AwayScore     sql.NullInt64 `json:"awayScore"`
	Status        string        `json:"status"`
}

func (q *Queries) CreateLeagueMatch(ctx context.Context, arg CreateLeagueMatchParams) (LeagueMatch, error) {
	row := q.queryRow(ctx, q.createLeagueMatchStmt, createLeagueMatch,
		arg.LeagueID,
		arg.HomeTeamID,
		arg.AwayTeamID,
		arg.ReservationID,
		arg.ScheduledTime,
		arg.HomeScore,
		arg.AwayScore,
		arg.Status,
	)
	var i LeagueMatch
	err := row.Scan(
		&i.ID,
		&i.LeagueID,
		&i.HomeTeamID,
		&i.AwayTeamID,
		&i.ReservationID,
		&i.ScheduledTime,
		&i.HomeScore,
		&i.AwayScore,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createLeagueTeam = `-- name: CreateLeagueTeam :one
INSERT INTO league_teams (
    league_id,
    name,
    captain_user_id,
    status
) VALUES (
    ?1,
    ?2,
    ?3,
    ?4
)
RETURNING id, league_id, name, captain_user_id, status, created_at, updated_at
`

type CreateLeagueTeamParams struct {
	LeagueID      int64  `json:"leagueId"`
	Name          string `json:"name"`
	CaptainUserID int64  `json:"captainUserId"`
	Status        string `json:"status"`
}

func (q *Queries) CreateLeagueTeam(ctx context.Context, arg CreateLeagueTeamParams) (LeagueTeam, error) {
	row := q.queryRow(ctx, q.createLeagueTeamStmt, createLeagueTeam,
		arg.LeagueID,
		arg.Name,
		arg.CaptainUserID,
		arg.Status,
	)
	var i LeagueTeam
	err := row.Scan(
		&i.ID,
		&i.LeagueID,
		&i.Name,
		&i.CaptainUserID,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getLeague = `-- name: GetLeague :one
SELECT id, facility_id, name, format, start_date, end_date, division_config,
    min_team_size, max_team_size, roster_lock_date, status, created_at, updated_at
FROM leagues
WHERE id = ?1
`

func (q *Queries) GetLeague(ctx context.Context, id int64) (League, error) {
	row := q.queryRow(ctx, q.getLeagueStmt, getLeague, id)
	var i League
	err := row.Scan(
		&i.ID,
		&i.FacilityID,
		&i.Name,
		&i.Format,
		&i.StartDate,
		&i.EndDate,
		&i.DivisionConfig,
		&i.MinTeamSize,
		&i.MaxTeamSize,
		&i.RosterLockDate,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getLeagueTeam = `-- name: GetLeagueTeam :one
SELECT id, league_id, name, captain_user_id, status, created_at, updated_at
FROM league_teams
WHERE id = ?1
`

func (q *Queries) GetLeagueTeam(ctx context.Context, id int64) (LeagueTeam, error) {
	row := q.queryRow(ctx, q.getLeagueTeamStmt, getLeagueTeam, id)
	var i LeagueTeam
	err := row.Scan(
		&i.ID,
		&i.LeagueID,
		&i.Name,
		&i.CaptainUserID,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listLeagueMatches = `-- name: ListLeagueMatches :many
SELECT id, league_id, home_team_id, away_team_id, reservation_id,
    scheduled_time, home_score, away_score, status, created_at, updated_at
FROM league_matches
WHERE league_id = ?1
ORDER BY scheduled_time
`

func (q *Queries) ListLeagueMatches(ctx context.Context, leagueID int64) ([]LeagueMatch, error) {
	rows, err := q.query(ctx, q.listLeagueMatchesStmt, listLeagueMatches, leagueID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []LeagueMatch
	for rows.Next() {
		var i LeagueMatch
		if err := rows.Scan(
			&i.ID,
			&i.LeagueID,
			&i.HomeTeamID,
			&i.AwayTeamID,
			&i.ReservationID,
			&i.ScheduledTime,
			&i.HomeScore,
			&i.AwayScore,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listLeagueTeams = `-- name: ListLeagueTeams :many
SELECT id, league_id, name, captain_user_id, status, created_at, updated_at
FROM league_teams
WHERE league_id = ?1
ORDER BY name
`

func (q *Queries) ListLeagueTeams(ctx context.Context, leagueID int64) ([]LeagueTeam, error) {
	rows, err := q.query(ctx, q.listLeagueTeamsStmt, listLeagueTeams, leagueID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []LeagueTeam
	for rows.Next() {
		var i LeagueTeam
		if err := rows.Scan(
			&i.ID,
			&i.LeagueID,
			&i.Name,
			&i.CaptainUserID,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listLeaguesByFacility = `-- name: ListLeaguesByFacility :many
SELECT id, facility_id, name, format, start_date, end_date, division_config,
    min_team_size, max_team_size, roster_lock_date, status, created_at, updated_at
FROM leagues
WHERE facility_id = ?1
ORDER BY start_date DESC, name
`

func (q *Queries) ListLeaguesByFacility(ctx context.Context, facilityID int64) ([]League, error) {
	rows, err := q.query(ctx, q.listLeaguesByFacilityStmt, listLeaguesByFacility, facilityID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []League
	for rows.Next() {
		var i League
		if err := rows.Scan(
			&i.ID,
			&i.FacilityID,
			&i.Name,
			&i.Format,
			&i.StartDate,
			&i.EndDate,
			&i.DivisionConfig,
			&i.MinTeamSize,
			&i.MaxTeamSize,
			&i.RosterLockDate,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTeamMembers = `-- name: ListTeamMembers :many
SELECT id, league_team_id, user_id, is_free_agent, created_at
FROM league_team_members
WHERE league_team_id = ?1
ORDER BY created_at
`

func (q *Queries) ListTeamMembers(ctx context.Context, leagueTeamID int64) ([]LeagueTeamMember, error) {
	rows, err := q.query(ctx, q.listTeamMembersStmt, listTeamMembers, leagueTeamID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []LeagueTeamMember
	for rows.Next() {
		var i LeagueTeamMember
		if err := rows.Scan(
			&i.ID,
			&i.LeagueTeamID,
			&i.UserID,
			&i.IsFreeAgent,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateMatchResult = `-- name: UpdateMatchResult :one
UPDATE league_matches
SET home_score = ?1,
    away_score = ?2,
    status = ?3,
    updated_at = CURRENT_TIMESTAMP
WHERE id = ?4
RETURNING id, league_id, home_team_id, away_team_id, reservation_id,
    scheduled_time, home_score, away_score, status, created_at, updated_at
`

type UpdateMatchResultParams struct {
	HomeScore sql.NullInt64 `json:"homeScore"`
	AwayScore sql.NullInt64 `json:"awayScore"`
	Status    string        `json:"status"`
	ID        int64         `json:"id"`
}

func (q *Queries) UpdateMatchResult(ctx context.Context, arg UpdateMatchResultParams) (LeagueMatch, error) {
	row := q.queryRow(ctx, q.updateMatchResultStmt, updateMatchResult,
		arg.HomeScore,
		arg.AwayScore,
		arg.Status,
		arg.ID,
	)
	var i LeagueMatch
	err := row.Scan(
		&i.ID,
		&i.LeagueID,
		&i.HomeTeamID,
		&i.AwayTeamID,
		&i.ReservationID,
		&i.ScheduledTime,
		&i.HomeScore,
		&i.AwayScore,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

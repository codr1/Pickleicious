// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: lesson_packages.sql

package db

import (
	"context"
	"database/sql"
	"time"
)

const countLessonPackageTypesByFacility = `-- name: CountLessonPackageTypesByFacility :one
SELECT COUNT(*)
FROM lesson_package_types
WHERE facility_id = ?1
`

func (q *Queries) CountLessonPackageTypesByFacility(ctx context.Context, facilityID int64) (int64, error) {
	row := q.queryRow(ctx, q.countLessonPackageTypesByFacilityStmt, countLessonPackageTypesByFacility, facilityID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createLessonPackage = `-- name: CreateLessonPackage :one
INSERT INTO lesson_packages (
    pack_type_id,
    user_id,
    purchase_date,
    expires_at,
    lessons_remaining,
    status
)
SELECT
    lpt.id,
    ?1,
    ?2,
    datetime(?2, '+' || lpt.valid_days || ' days'),
    lpt.lesson_count,
    ?3
FROM lesson_package_types lpt
WHERE lpt.id = ?4
  AND lpt.status = 'active'
RETURNING id, pack_type_id, user_id, purchase_date, expires_at,
    lessons_remaining, status, created_at, updated_at
`

type CreateLessonPackageParams struct {
	UserID       int64     `json:"userId"`
	PurchaseDate time.Time `json:"purchaseDate"`
	Status       string    `json:"status"`
	PackTypeID   int64     `json:"packTypeId"`
}

func (q *Queries) CreateLessonPackage(ctx context.Context, arg CreateLessonPackageParams) (LessonPackage, error) {
	row := q.queryRow(ctx, q.createLessonPackageStmt, createLessonPackage,
		arg.UserID,
		arg.PurchaseDate,
		arg.Status,
		arg.PackTypeID,
	)
	var i LessonPackage
	err := row.Scan(
		&i.ID,
		&i.PackTypeID,
		&i.UserID,
		&i.PurchaseDate,
		&i.ExpiresAt,
		&i.LessonsRemaining,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createLessonPackageRedemption = `-- name: CreateLessonPackageRedemption :one
INSERT INTO lesson_package_redemptions (
    lesson_package_id,
    facility_id,
    redeemed_at,
    reservation_id
) VALUES (
    ?1,
    ?2,
    ?3,
    ?4
)
RETURNING id, lesson_package_id, facility_id, redeemed_at, reservation_id,
    created_at
`

type CreateLessonPackageRedemptionParams struct {
	LessonPackageID int64         `json:"lessonPackageId"`
	FacilityID      int64         `json:"facilityId"`
	RedeemedAt      time.Time     `json:"redeemedAt"`
	ReservationID   sql.NullInt64 `json:"reservationId"`
}

func (q *Queries) CreateLessonPackageRedemption(ctx context.Context, arg CreateLessonPackageRedemptionParams) (LessonPackageRedemption, error) {
	row := q.queryRow(ctx, q.createLessonPackageRedemptionStmt, createLessonPackageRedemption,
		arg.LessonPackageID,
		arg.FacilityID,
		arg.RedeemedAt,
		arg.ReservationID,
	)
	var i LessonPackageRedemption
	err := row.Scan(
		&i.ID,
		&i.LessonPackageID,
		&i.FacilityID,
		&i.RedeemedAt,
		&i.ReservationID,
		&i.CreatedAt,
	)
	return i, err
}

const createLessonPackageType = `-- name: CreateLessonPackageType :one

INSERT INTO lesson_package_types (
    facility_id,
    name,
    price_cents,
    lesson_count,
    valid_days,
    status
) VALUES (
    ?1,
    ?2,
    ?3,
    ?4,
    ?5,
    ?6
)
RETURNING id, facility_id, name, price_cents, lesson_count, valid_days, status,
    created_at, updated_at
`

type CreateLessonPackageTypeParams struct {
	FacilityID  int64  `json:"facilityId"`
	Name        string `json:"name"`
	PriceCents  int64  `json:"priceCents"`
	LessonCount int64  `json:"lessonCount"`
	ValidDays   int64  `json:"validDays"`
	Status      string `json:"status"`
}

// internal/db/queries/lesson_packages.sql
func (q *Queries) CreateLessonPackageType(ctx context.Context, arg CreateLessonPackageTypeParams) (LessonPackageType, error) {
	row := q.queryRow(ctx, q.createLessonPackageTypeStmt, createLessonPackageType,
		arg.FacilityID,
		arg.Name,
		arg.PriceCents,
		arg.LessonCount,
		arg.ValidDays,
		arg.Status,
	)
	var i LessonPackageType
	err := row.Scan(
		&i.ID,
		&i.FacilityID,
		&i.Name,
		&i.PriceCents,
		&i.LessonCount,
		&i.ValidDays,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deactivateLessonPackageType = `-- name: DeactivateLessonPackageType :one
UPDATE lesson_package_types
SET status = 'inactive',
    updated_at = CURRENT_TIMESTAMP
WHERE id = ?1
  AND facility_id = ?2
RETURNING id, facility_id, name, price_cents, lesson_count, valid_days, status,
    created_at, updated_at
`

type DeactivateLessonPackageTypeParams struct {
	ID         int64 `json:"id"`
	FacilityID int64 `json:"facilityId"`
}

func (q *Queries) DeactivateLessonPackageType(ctx context.Context, arg DeactivateLessonPackageTypeParams) (LessonPackageType, error) {
	row := q.queryRow(ctx, q.deactivateLessonPackageTypeStmt, deactivateLessonPackageType, arg.ID, arg.FacilityID)
	var i LessonPackageType
	err := row.Scan(
		&i.ID,
		&i.FacilityID,
		&i.Name,
		&i.PriceCents,
		&i.LessonCount,
		&i.ValidDays,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const decrementLessonPackageLesson = `-- name: DecrementLessonPackageLesson :one
UPDATE lesson_packages
SET lessons_remaining = lessons_remaining - 1,
    status = CASE
        WHEN lessons_remaining - 1 <= 0 THEN 'depleted'
        ELSE status
    END,
    updated_at = CURRENT_TIMESTAMP
WHERE id = ?1
  AND status = 'active'
  AND lessons_remaining > 0
  AND expires_at > CURRENT_TIMESTAMP
RETURNING id, pack_type_id, user_id, purchase_date, expires_at,
    lessons_remaining, status, created_at, updated_at
`

func (q *Queries) DecrementLessonPackageLesson(ctx context.Context, id int64) (LessonPackage, error) {
	row := q.queryRow(ctx, q.decrementLessonPackageLessonStmt, decrementLessonPackageLesson, id)
	var i LessonPackage
	err := row.Scan(
		&i.ID,
		&i.PackTypeID,
		&i.UserID,
		&i.PurchaseDate,
		&i.ExpiresAt,
		&i.LessonsRemaining,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteLessonPackageRedemptionsByReservationID = `-- name: DeleteLessonPackageRedemptionsByReservationID :exec
DELETE FROM lesson_package_redemptions
WHERE reservation_id = ?1
`

func (q *Queries) DeleteLessonPackageRedemptionsByReservationID(ctx context.Context, reservationID sql.NullInt64) error {
	_, err := q.exec(ctx, q.deleteLessonPackageRedemptionsByReservationIDStmt, deleteLessonPackageRedemptionsByReservationID, reservationID)
	return err
}

const getEligibleLessonPackageForUser = `-- name: GetEligibleLessonPackageForUser :one
SELECT lp.id, lp.pack_type_id, lp.user_id, lp.purchase_date, lp.expires_at,
    lp.lessons_remaining, lp.status, lp.created_at, lp.updated_at
FROM lesson_packages lp
JOIN lesson_package_types lpt ON lpt.id = lp.pack_type_id
WHERE lp.user_id = ?1
  AND lpt.facility_id = ?2
  AND lp.status = 'active'
  AND lp.lessons_remaining > 0
  AND lp.expires_at > ?3
ORDER BY lp.expires_at
LIMIT 1
`

type GetEligibleLessonPackageForUserParams struct {
	UserID         int64     `json:"userId"`
	FacilityID     int64     `json:"facilityId"`
	ComparisonTime time.Time `json:"comparisonTime"`
}

func (q *Queries) GetEligibleLessonPackageForUser(ctx context.Context, arg GetEligibleLessonPackageForUserParams) (LessonPackage, error) {
	row := q.queryRow(ctx, q.getEligibleLessonPackageForUserStmt, getEligibleLessonPackageForUser, arg.UserID, arg.FacilityID, arg.ComparisonTime)
	var i LessonPackage
	err := row.Scan(
		&i.ID,
		&i.PackTypeID,
		&i.UserID,
		&i.PurchaseDate,
		&i.ExpiresAt,
		&i.LessonsRemaining,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getLessonPackage = `-- name: GetLessonPackage :one
SELECT id, pack_type_id, user_id, purchase_date, expires_at,
    lessons_remaining, status, created_at, updated_at
FROM lesson_packages
WHERE id = ?1
  AND user_id = ?2
`

type GetLessonPackageParams struct {
	ID     int64 `json:"id"`
	UserID int64 `json:"userId"`
}

func (q *Queries) GetLessonPackage(ctx context.Context, arg GetLessonPackageParams) (LessonPackage, error) {
	row := q.queryRow(ctx, q.getLessonPackageStmt, getLessonPackage, arg.ID, arg.UserID)
	var i LessonPackage
	err := row.Scan(
		&i.ID,
		&i.PackTypeID,
		&i.UserID,
		&i.PurchaseDate,
		&i.ExpiresAt,
		&i.LessonsRemaining,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getLessonPackageRedemptionInfo = `-- name: GetLessonPackageRedemptionInfo :one
SELECT lp.id AS lesson_package_id,
    lp.pack_type_id,
    lpt.facility_id AS pack_facility_id,
    f.organization_id AS organization_id
FROM lesson_packages lp
JOIN lesson_package_types lpt ON lpt.id = lp.pack_type_id
JOIN facilities f ON f.id = lpt.facility_id
WHERE lp.id = ?1
`

type GetLessonPackageRedemptionInfoRow struct {
	LessonPackageID int64 `json:"lessonPackageId"`
	PackTypeID      int64 `json:"packTypeId"`
	PackFacilityID  int64 `json:"packFacilityId"`
	OrganizationID  int64 `json:"organizationId"`
}

func (q *Queries) GetLessonPackageRedemptionInfo(ctx context.Context, id int64) (GetLessonPackageRedemptionInfoRow, error) {
	row := q.queryRow(ctx, q.getLessonPackageRedemptionInfoStmt, getLessonPackageRedemptionInfo, id)
	var i GetLessonPackageRedemptionInfoRow
	err := row.Scan(
		&i.LessonPackageID,
		&i.PackTypeID,
		&i.PackFacilityID,
		&i.OrganizationID,
	)
	return i, err
}

const getLessonPackageType = `-- name: GetLessonPackageType :one
SELECT id, facility_id, name, price_cents, lesson_count, valid_days, status,
    created_at, updated_at
FROM lesson_package_types
WHERE id = ?1
  AND facility_id = ?2
`

type GetLessonPackageTypeParams struct {
	ID         int64 `json:"id"`
	FacilityID int64 `json:"facilityId"`
}

func (q *Queries) GetLessonPackageType(ctx context.Context, arg GetLessonPackageTypeParams) (LessonPackageType, error) {
	row := q.queryRow(ctx, q.getLessonPackageTypeStmt, getLessonPackageType, arg.ID, arg.FacilityID)
	var i LessonPackageType
	err := row.Scan(
		&i.ID,
		&i.FacilityID,
		&i.Name,
		&i.PriceCents,
		&i.LessonCount,
		&i.ValidDays,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listActiveLessonPackagesForUser = `-- name: ListActiveLessonPackagesForUser :many
SELECT id, pack_type_id, user_id, purchase_date, expires_at,
    lessons_remaining, status, created_at, updated_at
FROM lesson_packages
WHERE user_id = ?1
  AND status = 'active'
  AND lessons_remaining > 0
  AND expires_at > ?2
ORDER BY expires_at
`

type ListActiveLessonPackagesForUserParams struct {
	UserID         int64     `json:"userId"`
	ComparisonTime time.Time `json:"comparisonTime"`
}

func (q *Queries) ListActiveLessonPackagesForUser(ctx context.Context, arg ListActiveLessonPackagesForUserParams) ([]LessonPackage, error) {
	rows, err := q.query(ctx, q.listActiveLessonPackagesForUserStmt, listActiveLessonPackagesForUser, arg.UserID, arg.ComparisonTime)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []LessonPackage
	for rows.Next() {
		var i LessonPackage
		if err := rows.Scan(
			&i.ID,
			&i.PackTypeID,
			&i.UserID,
			&i.PurchaseDate,
			&i.ExpiresAt,
			&i.LessonsRemaining,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listActiveLessonPackagesForUserByFacility = `-- name: ListActiveLessonPackagesForUserByFacility :many
SELECT lp.id, lp.pack_type_id, lp.user_id, lp.purchase_date, lp.expires_at,
    lp.lessons_remaining, lp.status, lp.created_at, lp.updated_at
FROM lesson_packages lp
JOIN lesson_package_types lpt ON lpt.id = lp.pack_type_id
WHERE lp.user_id = ?1
  AND lpt.facility_id = ?2
  AND lp.status = 'active'
  AND lp.lessons_remaining > 0
  AND lp.expires_at > ?3
ORDER BY lp.expires_at
`

type ListActiveLessonPackagesForUserByFacilityParams struct {
	UserID         int64     `json:"userId"`
	FacilityID     int64     `json:"facilityId"`
	ComparisonTime time.Time `json:"comparisonTime"`
}

func (q *Queries) ListActiveLessonPackagesForUserByFacility(ctx context.Context, arg ListActiveLessonPackagesForUserByFacilityParams) ([]LessonPackage, error) {
	rows, err := q.query(ctx, q.listActiveLessonPackagesForUserByFacilityStmt, listActiveLessonPackagesForUserByFacility, arg.UserID, arg.FacilityID, arg.ComparisonTime)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []LessonPackage
	for rows.Next() {
		var i LessonPackage
		if err := rows.Scan(
			&i.ID,
			&i.PackTypeID,
			&i.UserID,
			&i.PurchaseDate,
			&i.ExpiresAt,
			&i.LessonsRemaining,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listActiveLessonPackagesForUserByOrganization = `-- name: ListActiveLessonPackagesForUserByOrganization :many
SELECT lp.id, lp.pack_type_id, lp.user_id, lp.purchase_date, lp.expires_at,
    lp.lessons_remaining, lp.status, lp.created_at, lp.updated_at
FROM lesson_packages lp
JOIN lesson_package_types lpt ON lpt.id = lp.pack_type_id
JOIN facilities f ON f.id = lpt.facility_id
WHERE lp.user_id = ?1
  AND f.organization_id = ?2
  AND lp.status = 'active'
  AND lp.lessons_remaining > 0
  AND lp.expires_at > ?3
ORDER BY lp.expires_at
`

type ListActiveLessonPackagesForUserByOrganizationParams struct {
	UserID         int64     `json:"userId"`
	OrganizationID int64     `json:"organizationId"`
	ComparisonTime time.Time `json:"comparisonTime"`
}

func (q *Queries) ListActiveLessonPackagesForUserByOrganization(ctx context.Context, arg ListActiveLessonPackagesForUserByOrganizationParams) ([]LessonPackage, error) {
	rows, err := q.query(ctx, q.listActiveLessonPackagesForUserByOrganizationStmt, listActiveLessonPackagesForUserByOrganization, arg.UserID, arg.OrganizationID, arg.ComparisonTime)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []LessonPackage
	for rows.Next() {
		var i LessonPackage
		if err := rows.Scan(
			&i.ID,
			&i.PackTypeID,
			&i.UserID,
			&i.PurchaseDate,
			&i.ExpiresAt,
			&i.LessonsRemaining,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listLessonPackageRedemptionsByReservationID = `-- name: ListLessonPackageRedemptionsByReservationID :many
SELECT id, lesson_package_id
FROM lesson_package_redemptions
WHERE reservation_id = ?1
`

type ListLessonPackageRedemptionsByReservationIDRow struct {
	ID              int64 `json:"id"`
	LessonPackageID int64 `json:"lessonPackageId"`
}

func (q *Queries) ListLessonPackageRedemptionsByReservationID(ctx context.Context, reservationID sql.NullInt64) ([]ListLessonPackageRedemptionsByReservationIDRow, error) {
	rows, err := q.query(ctx, q.listLessonPackageRedemptionsByReservationIDStmt, listLessonPackageRedemptionsByReservationID, reservationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListLessonPackageRedemptionsByReservationIDRow
	for rows.Next() {
		var i ListLessonPackageRedemptionsByReservationIDRow
		if err := rows.Scan(&i.ID, &i.LessonPackageID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listLessonPackageTypes = `-- name: ListLessonPackageTypes :many
SELECT id, facility_id, name, price_cents, lesson_count, valid_days, status,
    created_at, updated_at
FROM lesson_package_types
WHERE facility_id = ?1
ORDER BY name
`

func (q *Queries) ListLessonPackageTypes(ctx context.Context, facilityID int64) ([]LessonPackageType, error) {
	rows, err := q.query(ctx, q.listLessonPackageTypesStmt, listLessonPackageTypes, facilityID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []LessonPackageType
	for rows.Next() {
		var i LessonPackageType
		if err := rows.Scan(
			&i.ID,
			&i.FacilityID,
			&i.Name,
			&i.PriceCents,
			&i.LessonCount,
			&i.ValidDays,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const restoreLessonPackageLesson = `-- name: RestoreLessonPackageLesson :one
UPDATE lesson_packages
SET lessons_remaining = lessons_remaining + 1,
    status = CASE
        WHEN status = 'depleted' THEN 'active'
        ELSE status
    END,
    updated_at = CURRENT_TIMESTAMP
WHERE id = ?1
RETURNING id, pack_type_id, user_id, purchase_date, expires_at,
    lessons_remaining, status, created_at, updated_at
`

func (q *Queries) RestoreLessonPackageLesson(ctx context.Context, id int64) (LessonPackage, error) {
	row := q.queryRow(ctx, q.restoreLessonPackageLessonStmt, restoreLessonPackageLesson, id)
	var i LessonPackage
	err := row.Scan(
		&i.ID,
		&i.PackTypeID,
		&i.UserID,
		&i.PurchaseDate,
		&i.ExpiresAt,
		&i.LessonsRemaining,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateLessonPackageType = `-- name: UpdateLessonPackageType :one
UPDATE lesson_package_types
SET name = ?1,
    price_cents = ?2,
    lesson_count = ?3,
    valid_days = ?4,
    updated_at = CURRENT_TIMESTAMP
WHERE id = ?5
  AND facility_id = ?6
RETURNING id, facility_id, name, price_cents, lesson_count, valid_days, status,
    created_at, updated_at
`

type UpdateLessonPackageTypeParams struct {
	Name        string `json:"name"`
	PriceCents  int64  `json:"priceCents"`
	LessonCount int64  `json:"lessonCount"`
	ValidDays   int64  `json:"validDays"`
	ID          int64  `json:"id"`
	FacilityID  int64  `json:"facilityId"`
}

func (q *Queries) UpdateLessonPackageType(ctx context.Context, arg UpdateLessonPackageTypeParams) (LessonPackageType, error) {
	row := q.queryRow(ctx, q.updateLessonPackageTypeStmt, updateLessonPackageType,
		arg.Name,
		arg.PriceCents,
		arg.LessonCount,
		arg.ValidDays,
		arg.ID,
		arg.FacilityID,
	)
	var i LessonPackageType
	err := row.Scan(
		&i.ID,
		&i.FacilityID,
		&i.Name,
		&i.PriceCents,
		&i.LessonCount,
		&i.ValidDays,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: reservations.sql

package db

import (
	"context"
	"database/sql"
	"time"
)

const addParticipant = `-- name: AddParticipant :exec
INSERT INTO reservation_participants (reservation_id, user_id)
VALUES (?1, ?2)
`

type AddParticipantParams struct {
	ReservationID int64 `json:"reservationId"`
	UserID        int64 `json:"userId"`
}

func (q *Queries) AddParticipant(ctx context.Context, arg AddParticipantParams) error {
	_, err := q.exec(ctx, q.addParticipantStmt, addParticipant, arg.ReservationID, arg.UserID)
	return err
}

const countActiveMemberReservations = `-- name: CountActiveMemberReservations :one
SELECT COUNT(*)
FROM reservations r
JOIN reservation_types rt ON rt.id = r.reservation_type_id
WHERE r.facility_id = ?1
  AND r.primary_user_id = ?2
  AND r.start_time > CURRENT_TIMESTAMP
  AND rt.name IN ('GAME', 'PRO_SESSION')
  AND NOT EXISTS (
      SELECT 1
      FROM reservation_cancellations rcc
      WHERE rcc.reservation_id = r.id
  )
`

type CountActiveMemberReservationsParams struct {
	FacilityID    int64         `json:"facilityId"`
	PrimaryUserID sql.NullInt64 `json:"primaryUserId"`
}

func (q *Queries) CountActiveMemberReservations(ctx context.Context, arg CountActiveMemberReservationsParams) (int64, error) {
	row := q.queryRow(ctx, q.countActiveMemberReservationsStmt, countActiveMemberReservations, arg.FacilityID, arg.PrimaryUserID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createReservation = `-- name: CreateReservation :one
INSERT INTO reservations (
    facility_id,
    reservation_type_id,
    recurrence_rule_id,
    primary_user_id,
    created_by_user_id,
    pro_id,
    open_play_rule_id,
    start_time,
    end_time,
    is_open_event,
    teams_per_court,
    people_per_team
) VALUES (
    ?1,
    ?2,
    ?3,
    ?4,
    ?5,
    ?6,
    ?7,
    ?8,
    ?9,
    ?10,
    ?11,
    ?12
)
RETURNING id, facility_id, reservation_type_id, recurrence_rule_id,
    primary_user_id, created_by_user_id, pro_id, open_play_rule_id, start_time, end_time,
    is_open_event, teams_per_court, people_per_team, created_at, updated_at
`

type CreateReservationParams struct {
	FacilityID        int64         `json:"facilityId"`
	ReservationTypeID int64         `json:"reservationTypeId"`
	RecurrenceRuleID  sql.NullInt64 `json:"recurrenceRuleId"`
	PrimaryUserID     sql.NullInt64 `json:"primaryUserId"`
	CreatedByUserID   int64         `json:"createdByUserId"`
	ProID             sql.NullInt64 `json:"proId"`
	OpenPlayRuleID    sql.NullInt64 `json:"openPlayRuleId"`
	StartTime         time.Time     `json:"startTime"`
	EndTime           time.Time     `json:"endTime"`
	IsOpenEvent       bool          `json:"isOpenEvent"`
	TeamsPerCourt     sql.NullInt64 `json:"teamsPerCourt"`
	PeoplePerTeam     sql.NullInt64 `json:"peoplePerTeam"`
}

func (q *Queries) CreateReservation(ctx context.Context, arg CreateReservationParams) (Reservation, error) {
	row := q.queryRow(ctx, q.createReservationStmt, createReservation,
		arg.FacilityID,
		arg.ReservationTypeID,
		arg.RecurrenceRuleID,
		arg.PrimaryUserID,
		arg.CreatedByUserID,
		arg.ProID,
		arg.OpenPlayRuleID,
		arg.StartTime,
		arg.EndTime,
		arg.IsOpenEvent,
		arg.TeamsPerCourt,
		arg.PeoplePerTeam,
	)
	var i Reservation
	err := row.Scan(
		&i.ID,
		&i.FacilityID,
		&i.ReservationTypeID,
		&i.RecurrenceRuleID,
		&i.PrimaryUserID,
		&i.CreatedByUserID,
		&i.ProID,
		&i.OpenPlayRuleID,
		&i.StartTime,
		&i.EndTime,
		&i.IsOpenEvent,
		&i.TeamsPerCourt,
		&i.PeoplePerTeam,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteReservation = `-- name: DeleteReservation :execrows
DELETE FROM reservations
WHERE id = ?1
  AND facility_id = ?2
`

type DeleteReservationParams struct {
	ID         int64 `json:"id"`
	FacilityID int64 `json:"facilityId"`
}

func (q *Queries) DeleteReservation(ctx context.Context, arg DeleteReservationParams) (int64, error) {
	result, err := q.exec(ctx, q.deleteReservationStmt, deleteReservation, arg.ID, arg.FacilityID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const deleteReservationCourtsByReservationID = `-- name: DeleteReservationCourtsByReservationID :exec
DELETE FROM reservation_courts
WHERE reservation_id = ?1
`

func (q *Queries) DeleteReservationCourtsByReservationID(ctx context.Context, reservationID int64) error {
	_, err := q.exec(ctx, q.deleteReservationCourtsByReservationIDStmt, deleteReservationCourtsByReservationID, reservationID)
	return err
}

const deleteReservationParticipantsByReservationID = `-- name: DeleteReservationParticipantsByReservationID :exec
DELETE FROM reservation_participants
WHERE reservation_id = ?1
`

func (q *Queries) DeleteReservationParticipantsByReservationID(ctx context.Context, reservationID int64) error {
	_, err := q.exec(ctx, q.deleteReservationParticipantsByReservationIDStmt, deleteReservationParticipantsByReservationID, reservationID)
	return err
}

const getReservation = `-- name: GetReservation :one
SELECT id, facility_id, reservation_type_id, recurrence_rule_id,
    primary_user_id, created_by_user_id, pro_id, open_play_rule_id, start_time, end_time,
    is_open_event, teams_per_court, people_per_team, created_at, updated_at
FROM reservations
WHERE id = ?1
  AND facility_id = ?2
`

type GetReservationParams struct {
	ID         int64 `json:"id"`
	FacilityID int64 `json:"facilityId"`
}

func (q *Queries) GetReservation(ctx context.Context, arg GetReservationParams) (Reservation, error) {
	row := q.queryRow(ctx, q.getReservationStmt, getReservation, arg.ID, arg.FacilityID)
	var i Reservation
	err := row.Scan(
		&i.ID,
		&i.FacilityID,
		&i.ReservationTypeID,
		&i.RecurrenceRuleID,
		&i.PrimaryUserID,
		&i.CreatedByUserID,
		&i.ProID,
		&i.OpenPlayRuleID,
		&i.StartTime,
		&i.EndTime,
		&i.IsOpenEvent,
		&i.TeamsPerCourt,
		&i.PeoplePerTeam,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getReservationByID = `-- name: GetReservationByID :one
SELECT id, facility_id, reservation_type_id, recurrence_rule_id,
    primary_user_id, created_by_user_id, pro_id, open_play_rule_id, start_time, end_time,
    is_open_event, teams_per_court, people_per_team, created_at, updated_at
FROM reservations
WHERE id = ?1
`

func (q *Queries) GetReservationByID(ctx context.Context, id int64) (Reservation, error) {
	row := q.queryRow(ctx, q.getReservationByIDStmt, getReservationByID, id)
	var i Reservation
	err := row.Scan(
		&i.ID,
		&i.FacilityID,
		&i.ReservationTypeID,
		&i.RecurrenceRuleID,
		&i.PrimaryUserID,
		&i.CreatedByUserID,
		&i.ProID,
		&i.OpenPlayRuleID,
		&i.StartTime,
		&i.EndTime,
		&i.IsOpenEvent,
		&i.TeamsPerCourt,
		&i.PeoplePerTeam,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getReservationType = `-- name: GetReservationType :one
SELECT id, name, description, color, created_at, updated_at
FROM reservation_types
WHERE id = ?1
`

func (q *Queries) GetReservationType(ctx context.Context, id int64) (ReservationType, error) {
	row := q.queryRow(ctx, q.getReservationTypeStmt, getReservationType, id)
	var i ReservationType
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Color,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getReservationTypeByName = `-- name: GetReservationTypeByName :one
SELECT id, name, description, color, created_at, updated_at
FROM reservation_types
WHERE LOWER(name) = LOWER(?1)
`

func (q *Queries) GetReservationTypeByName(ctx context.Context, name string) (ReservationType, error) {
	row := q.queryRow(ctx, q.getReservationTypeByNameStmt, getReservationTypeByName, name)
	var i ReservationType
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Color,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getReservationTypeNameByReservationID = `-- name: GetReservationTypeNameByReservationID :one
SELECT rt.name
FROM reservations r
JOIN reservation_types rt ON rt.id = r.reservation_type_id
WHERE r.id = ?1
`

func (q *Queries) GetReservationTypeNameByReservationID(ctx context.Context, reservationID int64) (string, error) {
	row := q.queryRow(ctx, q.getReservationTypeNameByReservationIDStmt, getReservationTypeNameByReservationID, reservationID)
	var name string
	err := row.Scan(&name)
	return name, err
}

const listParticipantsForReservation = `-- name: ListParticipantsForReservation :many
SELECT u.id, u.email, u.phone, u.first_name, u.last_name, u.photo_url,
    u.is_member, u.is_staff, u.membership_level, u.status
FROM reservation_participants rp
JOIN users u ON u.id = rp.user_id
WHERE rp.reservation_id = ?1
ORDER BY u.last_name, u.first_name
`

type ListParticipantsForReservationRow struct {
	ID              int64          `json:"id"`
	Email           sql.NullString `json:"email"`
	Phone           sql.NullString `json:"phone"`
	FirstName       string         `json:"firstName"`
	LastName        string         `json:"lastName"`
	PhotoUrl        sql.NullString `json:"photoUrl"`
	IsMember        bool           `json:"isMember"`
	IsStaff         bool           `json:"isStaff"`
	MembershipLevel int64          `json:"membershipLevel"`
	Status          string         `json:"status"`
}

func (q *Queries) ListParticipantsForReservation(ctx context.Context, reservationID int64) ([]ListParticipantsForReservationRow, error) {
	rows, err := q.query(ctx, q.listParticipantsForReservationStmt, listParticipantsForReservation, reservationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListParticipantsForReservationRow
	for rows.Next() {
		var i ListParticipantsForReservationRow
		if err := rows.Scan(
			&i.ID,
			&i.Email,
			&i.Phone,
			&i.FirstName,
			&i.LastName,
			&i.PhotoUrl,
			&i.IsMember,
			&i.IsStaff,
			&i.MembershipLevel,
			&i.Status,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listReservationCourtsByDateRange = `-- name: ListReservationCourtsByDateRange :many
SELECT rc.reservation_id, c.court_number
FROM reservation_courts rc
JOIN reservations r ON r.id = rc.reservation_id
JOIN courts c ON c.id = rc.court_id
WHERE r.facility_id = ?1
  AND r.start_time < ?2
  AND r.end_time > ?3
  AND NOT EXISTS (
      SELECT 1
      FROM reservation_cancellations rcc
      WHERE rcc.reservation_id = r.id
  )
ORDER BY rc.reservation_id, c.court_number
`

type ListReservationCourtsByDateRangeParams struct {
	FacilityID int64     `json:"facilityId"`
	EndTime    time.Time `json:"endTime"`
	StartTime  time.Time `json:"startTime"`
}

type ListReservationCourtsByDateRangeRow struct {
	ReservationID int64 `json:"reservationId"`
	CourtNumber   int64 `json:"courtNumber"`
}

func (q *Queries) ListReservationCourtsByDateRange(ctx context.Context, arg ListReservationCourtsByDateRangeParams) ([]ListReservationCourtsByDateRangeRow, error) {
	rows, err := q.query(ctx, q.listReservationCourtsByDateRangeStmt, listReservationCourtsByDateRange, arg.FacilityID, arg.EndTime, arg.StartTime)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListReservationCourtsByDateRangeRow
	for rows.Next() {
		var i ListReservationCourtsByDateRangeRow
		if err := rows.Scan(&i.ReservationID, &i.CourtNumber); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listReservationTypes = `-- name: ListReservationTypes :many
SELECT id, name, description, color, created_at, updated_at
FROM reservation_types
ORDER BY name
`

func (q *Queries) ListReservationTypes(ctx context.Context) ([]ReservationType, error) {
	rows, err := q.query(ctx, q.listReservationTypesStmt, listReservationTypes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ReservationType
	for rows.Next() {
		var i ReservationType
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Color,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listReservationsByDateRange = `-- name: ListReservationsByDateRange :many
SELECT id, facility_id, reservation_type_id, recurrence_rule_id,
    primary_user_id, created_by_user_id, pro_id, open_play_rule_id, start_time, end_time,
    is_open_event, teams_per_court, people_per_team, created_at, updated_at
FROM reservations
WHERE facility_id = ?1
  AND start_time < ?2
  AND end_time > ?3
  AND NOT EXISTS (
      SELECT 1
      FROM reservation_cancellations rcc
      WHERE rcc.reservation_id = reservations.id
  )
ORDER BY start_time
`

type ListReservationsByDateRangeParams struct {
	FacilityID int64     `json:"facilityId"`
	EndTime    time.Time `json:"endTime"`
	StartTime  time.Time `json:"startTime"`
}

func (q *Queries) ListReservationsByDateRange(ctx context.Context, arg ListReservationsByDateRangeParams) ([]Reservation, error) {
	rows, err := q.query(ctx, q.listReservationsByDateRangeStmt, listReservationsByDateRange, arg.FacilityID, arg.EndTime, arg.StartTime)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Reservation
	for rows.Next() {
		var i Reservation
		if err := rows.Scan(
			&i.ID,
			&i.FacilityID,
			&i.ReservationTypeID,
			&i.RecurrenceRuleID,
			&i.PrimaryUserID,
			&i.CreatedByUserID,
			&i.ProID,
			&i.OpenPlayRuleID,
			&i.StartTime,
			&i.EndTime,
			&i.IsOpenEvent,
			&i.TeamsPerCourt,
			&i.PeoplePerTeam,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listReservationsByUserID = `-- name: ListReservationsByUserID :many
SELECT
    r.id,
    r.facility_id,
    r.reservation_type_id,
    r.recurrence_rule_id,
    r.primary_user_id,
    r.created_by_user_id,
    r.pro_id,
    r.open_play_rule_id,
    r.start_time,
    r.end_time,
    r.is_open_event,
    r.teams_per_court,
    r.people_per_team,
    r.created_at,
    r.updated_at,
    f.name AS facility_name,
    rt.name AS reservation_type_name,
    s.first_name AS pro_first_name,
    s.last_name AS pro_last_name,
    group_concat(DISTINCT COALESCE(NULLIF(c.name, ''), 'Court ' || c.court_number)) AS court_name
FROM reservations r
JOIN facilities f ON f.id = r.facility_id
LEFT JOIN reservation_types rt ON rt.id = r.reservation_type_id
LEFT JOIN staff s ON s.id = r.pro_id
LEFT JOIN reservation_courts rc ON rc.reservation_id = r.id
LEFT JOIN courts c ON c.id = rc.court_id
WHERE (
        r.primary_user_id = ?1
     OR EXISTS (
         SELECT 1
         FROM reservation_participants rp
         WHERE rp.reservation_id = r.id
           AND rp.user_id = ?1
     )
  )
  AND NOT EXISTS (
      SELECT 1
      FROM reservation_cancellations rcc
      WHERE rcc.reservation_id = r.id
  )
GROUP BY r.id,
    r.facility_id,
    r.reservation_type_id,
    r.recurrence_rule_id,
    r.primary_user_id,
    r.created_by_user_id,
    r.pro_id,
    r.open_play_rule_id,
    r.start_time,
    r.end_time,
    r.is_open_event,
    r.teams_per_court,
    r.people_per_team,
    r.created_at,
    r.updated_at,
    f.name,
    rt.name,
    s.first_name,
    s.last_name
ORDER BY r.start_time DESC
`

type ListReservationsByUserIDRow struct {
	ID                  int64          `json:"id"`
	FacilityID          int64          `json:"facilityId"`
	ReservationTypeID   int64          `json:"reservationTypeId"`
	RecurrenceRuleID    sql.NullInt64  `json:"recurrenceRuleId"`
	PrimaryUserID       sql.NullInt64  `json:"primaryUserId"`
	CreatedByUserID     int64          `json:"createdByUserId"`
	ProID               sql.NullInt64  `json:"proId"`
	OpenPlayRuleID      sql.NullInt64  `json:"openPlayRuleId"`
	StartTime           time.Time      `json:"startTime"`
	EndTime             time.Time      `json:"endTime"`
	IsOpenEvent         bool           `json:"isOpenEvent"`
	TeamsPerCourt       sql.NullInt64  `json:"teamsPerCourt"`
	PeoplePerTeam       sql.NullInt64  `json:"peoplePerTeam"`
	CreatedAt           time.Time      `json:"createdAt"`
	UpdatedAt           time.Time      `json:"updatedAt"`
	FacilityName        string         `json:"facilityName"`
	ReservationTypeName sql.NullString `json:"reservationTypeName"`
	ProFirstName        sql.NullString `json:"proFirstName"`
	ProLastName         sql.NullString `json:"proLastName"`
	CourtName           string         `json:"courtName"`
}

func (q *Queries) ListReservationsByUserID(ctx context.Context, userID sql.NullInt64) ([]ListReservationsByUserIDRow, error) {
	rows, err := q.query(ctx, q.listReservationsByUserIDStmt, listReservationsByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListReservationsByUserIDRow
	for rows.Next() {
		var i ListReservationsByUserIDRow
		if err := rows.Scan(
			&i.ID,
			&i.FacilityID,
			&i.ReservationTypeID,
			&i.RecurrenceRuleID,
			&i.PrimaryUserID,
			&i.CreatedByUserID,
			&i.ProID,
			&i.OpenPlayRuleID,
			&i.StartTime,
			&i.EndTime,
			&i.IsOpenEvent,
			&i.TeamsPerCourt,
			&i.PeoplePerTeam,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.FacilityName,
			&i.ReservationTypeName,
			&i.ProFirstName,
			&i.ProLastName,
			&i.CourtName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeParticipant = `-- name: RemoveParticipant :exec
DELETE FROM reservation_participants
WHERE reservation_id = ?1
  AND user_id = ?2
`

type RemoveParticipantParams struct {
	ReservationID int64 `json:"reservationId"`
	UserID        int64 `json:"userId"`
}

func (q *Queries) RemoveParticipant(ctx context.Context, arg RemoveParticipantParams) error {
	_, err := q.exec(ctx, q.removeParticipantStmt, removeParticipant, arg.ReservationID, arg.UserID)
	return err
}

const updateReservation = `-- name: UpdateReservation :one
UPDATE reservations
SET reservation_type_id = ?1,
    recurrence_rule_id = ?2,
    primary_user_id = ?3,
    pro_id = ?4,
    open_play_rule_id = ?5,
    start_time = ?6,
    end_time = ?7,
    is_open_event = ?8,
    teams_per_court = ?9,
    people_per_team = ?10,
    updated_at = CURRENT_TIMESTAMP
WHERE id = ?11
  AND facility_id = ?12
RETURNING id, facility_id, reservation_type_id, recurrence_rule_id,
    primary_user_id, created_by_user_id, pro_id, open_play_rule_id, start_time, end_time,
    is_open_event, teams_per_court, people_per_team, created_at, updated_at
`

type UpdateReservationParams struct {
	ReservationTypeID int64         `json:"reservationTypeId"`
	RecurrenceRuleID  sql.NullInt64 `json:"recurrenceRuleId"`
	PrimaryUserID     sql.NullInt64 `json:"primaryUserId"`
	ProID             sql.NullInt64 `json:"proId"`
	OpenPlayRuleID    sql.NullInt64 `json:"openPlayRuleId"`
	StartTime         time.Time     `json:"startTime"`
	EndTime           time.Time     `json:"endTime"`
	IsOpenEvent       bool          `json:"isOpenEvent"`
	TeamsPerCourt     sql.NullInt64 `json:"teamsPerCourt"`
	PeoplePerTeam     sql.NullInt64 `json:"peoplePerTeam"`
	ID                int64         `json:"id"`
	FacilityID        int64         `json:"facilityId"`
}

func (q *Queries) UpdateReservation(ctx context.Context, arg UpdateReservationParams) (Reservation, error) {
	row := q.queryRow(ctx, q.updateReservationStmt, updateReservation,
		arg.ReservationTypeID,
		arg.RecurrenceRuleID,
		arg.PrimaryUserID,
		arg.ProID,
		arg.OpenPlayRuleID,
		arg.StartTime,
		arg.EndTime,
		arg.IsOpenEvent,
		arg.TeamsPerCourt,
		arg.PeoplePerTeam,
		arg.ID,
		arg.FacilityID,
	)
	var i Reservation
	err := row.Scan(
		&i.ID,
		&i.FacilityID,
		&i.ReservationTypeID,
		&i.RecurrenceRuleID,
		&i.PrimaryUserID,
		&i.CreatedByUserID,
		&i.ProID,
		&i.OpenPlayRuleID,
		&i.StartTime,
		&i.EndTime,
		&i.IsOpenEvent,
		&i.TeamsPerCourt,
		&i.PeoplePerTeam,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

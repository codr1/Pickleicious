// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: schedules.sql

package db

import (
	"context"
)

const deleteOperatingHours = `-- name: DeleteOperatingHours :execrows
DELETE FROM operating_hours
WHERE facility_id = ? AND day_of_week = ?
`

type DeleteOperatingHoursParams struct {
	FacilityID int64 `json:"facilityId"`
	DayOfWeek  int64 `json:"dayOfWeek"`
}

func (q *Queries) DeleteOperatingHours(ctx context.Context, arg DeleteOperatingHoursParams) (int64, error) {
	result, err := q.exec(ctx, q.deleteOperatingHoursStmt, deleteOperatingHours, arg.FacilityID, arg.DayOfWeek)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const getFacilityHours = `-- name: GetFacilityHours :many
SELECT id, facility_id, day_of_week, opens_at, closes_at, created_at, updated_at FROM operating_hours
WHERE facility_id = ?
ORDER BY day_of_week
`

// internal/db/queries/schedules.sql
func (q *Queries) GetFacilityHours(ctx context.Context, facilityID int64) ([]OperatingHour, error) {
	rows, err := q.query(ctx, q.getFacilityHoursStmt, getFacilityHours, facilityID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []OperatingHour
	for rows.Next() {
		var i OperatingHour
		if err := rows.Scan(
			&i.ID,
			&i.FacilityID,
			&i.DayOfWeek,
			&i.OpensAt,
			&i.ClosesAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const operatingHoursExists = `-- name: OperatingHoursExists :one
SELECT COUNT(1) FROM operating_hours
WHERE facility_id = ? AND day_of_week = ?
`

type OperatingHoursExistsParams struct {
	FacilityID int64 `json:"facilityId"`
	DayOfWeek  int64 `json:"dayOfWeek"`
}

func (q *Queries) OperatingHoursExists(ctx context.Context, arg OperatingHoursExistsParams) (int64, error) {
	row := q.queryRow(ctx, q.operatingHoursExistsStmt, operatingHoursExists, arg.FacilityID, arg.DayOfWeek)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const upsertOperatingHours = `-- name: UpsertOperatingHours :one
INSERT INTO operating_hours (
    facility_id,
    day_of_week,
    opens_at,
    closes_at
) VALUES (?, ?, ?, ?)
ON CONFLICT(facility_id, day_of_week) DO UPDATE SET
    opens_at = excluded.opens_at,
    closes_at = excluded.closes_at,
    updated_at = CURRENT_TIMESTAMP
RETURNING id, facility_id, day_of_week, opens_at, closes_at, created_at, updated_at
`

type UpsertOperatingHoursParams struct {
	FacilityID int64       `json:"facilityId"`
	DayOfWeek  int64       `json:"dayOfWeek"`
	OpensAt    interface{} `json:"opensAt"`
	ClosesAt   interface{} `json:"closesAt"`
}

func (q *Queries) UpsertOperatingHours(ctx context.Context, arg UpsertOperatingHoursParams) (OperatingHour, error) {
	row := q.queryRow(ctx, q.upsertOperatingHoursStmt, upsertOperatingHours,
		arg.FacilityID,
		arg.DayOfWeek,
		arg.OpensAt,
		arg.ClosesAt,
	)
	var i OperatingHour
	err := row.Scan(
		&i.ID,
		&i.FacilityID,
		&i.DayOfWeek,
		&i.OpensAt,
		&i.ClosesAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

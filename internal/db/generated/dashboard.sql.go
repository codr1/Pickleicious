// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: dashboard.sql

package db

import (
	"context"
	"time"
)

const countCheckinsByFacilityInRange = `-- name: CountCheckinsByFacilityInRange :one
SELECT COUNT(*) AS checkins_count
FROM facility_visits
WHERE (?1 = 0 OR facility_id = ?1)
  AND check_in_time >= ?2
  AND check_in_time < ?3
`

type CountCheckinsByFacilityInRangeParams struct {
	FacilityID interface{} `json:"facilityId"`
	StartTime  time.Time   `json:"startTime"`
	EndTime    time.Time   `json:"endTime"`
}

func (q *Queries) CountCheckinsByFacilityInRange(ctx context.Context, arg CountCheckinsByFacilityInRangeParams) (int64, error) {
	row := q.queryRow(ctx, q.countCheckinsByFacilityInRangeStmt, countCheckinsByFacilityInRange, arg.FacilityID, arg.StartTime, arg.EndTime)
	var checkins_count int64
	err := row.Scan(&checkins_count)
	return checkins_count, err
}

const countReservationsByTypeInRange = `-- name: CountReservationsByTypeInRange :many
SELECT reservation_type_id,
    COUNT(*) AS reservation_count
FROM reservations
WHERE (?1 = 0 OR facility_id = ?1)
  AND start_time < ?2
  AND end_time > ?3
  AND NOT EXISTS (
      SELECT 1
      FROM reservation_cancellations rcc
      WHERE rcc.reservation_id = reservations.id
  )
GROUP BY reservation_type_id
ORDER BY reservation_type_id
`

type CountReservationsByTypeInRangeParams struct {
	FacilityID interface{} `json:"facilityId"`
	EndTime    time.Time   `json:"endTime"`
	StartTime  time.Time   `json:"startTime"`
}

type CountReservationsByTypeInRangeRow struct {
	ReservationTypeID int64 `json:"reservationTypeId"`
	ReservationCount  int64 `json:"reservationCount"`
}

func (q *Queries) CountReservationsByTypeInRange(ctx context.Context, arg CountReservationsByTypeInRangeParams) ([]CountReservationsByTypeInRangeRow, error) {
	rows, err := q.query(ctx, q.countReservationsByTypeInRangeStmt, countReservationsByTypeInRange, arg.FacilityID, arg.EndTime, arg.StartTime)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CountReservationsByTypeInRangeRow
	for rows.Next() {
		var i CountReservationsByTypeInRangeRow
		if err := rows.Scan(&i.ReservationTypeID, &i.ReservationCount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const countScheduledVsCompletedReservations = `-- name: CountScheduledVsCompletedReservations :many
SELECT CASE
        WHEN r.end_time < ?1 THEN 'completed'
        ELSE 'scheduled'
    END AS reservation_status,
    COUNT(*) AS reservation_count
FROM reservations r
WHERE (?2 = 0 OR r.facility_id = ?2)
  AND r.start_time < ?3
  AND r.end_time > ?4
  AND NOT EXISTS (
      SELECT 1
      FROM reservation_cancellations rcc
      WHERE rcc.reservation_id = r.id
  )
GROUP BY reservation_status
ORDER BY reservation_status
`

type CountScheduledVsCompletedReservationsParams struct {
	ComparisonTime time.Time   `json:"comparisonTime"`
	FacilityID     interface{} `json:"facilityId"`
	EndTime        time.Time   `json:"endTime"`
	StartTime      time.Time   `json:"startTime"`
}

type CountScheduledVsCompletedReservationsRow struct {
	ReservationStatus string `json:"reservationStatus"`
	ReservationCount  int64  `json:"reservationCount"`
}

func (q *Queries) CountScheduledVsCompletedReservations(ctx context.Context, arg CountScheduledVsCompletedReservationsParams) ([]CountScheduledVsCompletedReservationsRow, error) {
	rows, err := q.query(ctx, q.countScheduledVsCompletedReservationsStmt, countScheduledVsCompletedReservations,
		arg.ComparisonTime,
		arg.FacilityID,
		arg.EndTime,
		arg.StartTime,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CountScheduledVsCompletedReservationsRow
	for rows.Next() {
		var i CountScheduledVsCompletedReservationsRow
		if err := rows.Scan(&i.ReservationStatus, &i.ReservationCount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAvailableCourtHours = `-- name: GetAvailableCourtHours :one
WITH RECURSIVE date_range(day) AS (
    SELECT datetime(?1, 'start of day')
    UNION ALL
    SELECT datetime(day, '+1 day')
    FROM date_range
    WHERE day < datetime(?2, 'start of day')
),
facilities_scope AS (
    SELECT id AS facility_id
    FROM facilities
    WHERE ?3 = 0 OR id = ?3
),
court_count AS (
    SELECT courts.facility_id,
        COUNT(*) AS total_courts
    FROM courts
    JOIN facilities_scope fs ON fs.facility_id = courts.facility_id
    WHERE courts.facility_id = fs.facility_id
      AND status = 'active'
    GROUP BY courts.facility_id
),
hours_by_day AS (
    SELECT oh.facility_id,
        (julianday('2000-01-01 ' || oh.closes_at)
        - julianday('2000-01-01 ' || oh.opens_at)) * 24.0 AS open_hours
    FROM date_range dr
    JOIN operating_hours oh
      ON oh.facility_id IN (SELECT facility_id FROM facilities_scope)
     AND oh.day_of_week = CAST(strftime('%w', dr.day) AS INTEGER)
)
SELECT CAST(
        COALESCE(
            (
                SELECT SUM(hours_by_day.open_hours * court_count.total_courts)
                FROM hours_by_day
                JOIN court_count ON court_count.facility_id = hours_by_day.facility_id
            ),
            CAST(0 AS REAL)
        ) AS REAL
    ) AS available_court_hours
FROM facilities_scope
LIMIT 1
`

type GetAvailableCourtHoursParams struct {
	StartTime  interface{} `json:"startTime"`
	EndTime    interface{} `json:"endTime"`
	FacilityID interface{} `json:"facilityId"`
}

func (q *Queries) GetAvailableCourtHours(ctx context.Context, arg GetAvailableCourtHoursParams) (float64, error) {
	row := q.queryRow(ctx, q.getAvailableCourtHoursStmt, getAvailableCourtHours, arg.StartTime, arg.EndTime, arg.FacilityID)
	var available_court_hours float64
	err := row.Scan(&available_court_hours)
	return available_court_hours, err
}

const getBookedCourtHours = `-- name: GetBookedCourtHours :one
WITH booked AS (
    SELECT (julianday(
            CASE
                WHEN r.end_time < ?1 THEN r.end_time
                ELSE ?1
            END
        ) - julianday(
            CASE
                WHEN r.start_time > ?2 THEN r.start_time
                ELSE ?2
            END
        )) * 24.0 AS booked_hours
    FROM reservations r
    JOIN reservation_courts rc ON rc.reservation_id = r.id
    WHERE (?3 = 0 OR r.facility_id = ?3)
      AND r.start_time < ?1
      AND r.end_time > ?2
      AND NOT EXISTS (
          SELECT 1
          FROM reservation_cancellations rcc
          WHERE rcc.reservation_id = r.id
      )
)
SELECT CAST(COALESCE(SUM(booked_hours), 0) AS REAL) AS booked_court_hours
FROM booked
`

type GetBookedCourtHoursParams struct {
	EndTime    time.Time   `json:"endTime"`
	StartTime  time.Time   `json:"startTime"`
	FacilityID interface{} `json:"facilityId"`
}

func (q *Queries) GetBookedCourtHours(ctx context.Context, arg GetBookedCourtHoursParams) (float64, error) {
	row := q.queryRow(ctx, q.getBookedCourtHoursStmt, getBookedCourtHours, arg.EndTime, arg.StartTime, arg.FacilityID)
	var booked_court_hours float64
	err := row.Scan(&booked_court_hours)
	return booked_court_hours, err
}

const getCancellationMetricsInRange = `-- name: GetCancellationMetricsInRange :one
WITH cancellation_counts AS (
    SELECT COUNT(*) AS cancellations_count,
        CAST(IFNULL(SUM(rc.refund_percentage_applied), 0) AS REAL)
            AS total_refund_percentage
    FROM reservation_cancellations rc
    JOIN reservations r ON r.id = rc.reservation_id
    WHERE (?1 = 0 OR r.facility_id = ?1)
      AND rc.cancelled_at >= ?2
      AND rc.cancelled_at < ?3
),
reservation_counts AS (
    SELECT COUNT(*) AS total_reservations
    FROM reservations r
    WHERE (?1 = 0 OR r.facility_id = ?1)
      AND r.start_time < ?3
      AND r.end_time > ?2
)
SELECT cancellation_counts.cancellations_count,
    reservation_counts.total_reservations,
    CAST(
        COALESCE(
            CAST(cancellation_counts.cancellations_count AS REAL)
            / NULLIF(CAST(reservation_counts.total_reservations AS REAL), 0),
            0
        ) AS REAL
    ) AS cancellation_rate,
    CAST(cancellation_counts.total_refund_percentage AS REAL)
        AS total_refund_percentage
FROM cancellation_counts, reservation_counts
`

type GetCancellationMetricsInRangeParams struct {
	FacilityID interface{} `json:"facilityId"`
	StartTime  time.Time   `json:"startTime"`
	EndTime    time.Time   `json:"endTime"`
}

type GetCancellationMetricsInRangeRow struct {
	CancellationsCount    int64   `json:"cancellationsCount"`
	TotalReservations     int64   `json:"totalReservations"`
	CancellationRate      float64 `json:"cancellationRate"`
	TotalRefundPercentage float64 `json:"totalRefundPercentage"`
}

func (q *Queries) GetCancellationMetricsInRange(ctx context.Context, arg GetCancellationMetricsInRangeParams) (GetCancellationMetricsInRangeRow, error) {
	row := q.queryRow(ctx, q.getCancellationMetricsInRangeStmt, getCancellationMetricsInRange, arg.FacilityID, arg.StartTime, arg.EndTime)
	var i GetCancellationMetricsInRangeRow
	err := row.Scan(
		&i.CancellationsCount,
		&i.TotalReservations,
		&i.CancellationRate,
		&i.TotalRefundPercentage,
	)
	return i, err
}

// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: open_play_sessions.sql

package db

import (
	"context"
	"database/sql"
	"strings"
	"time"
)

const addOpenPlayParticipant = `-- name: AddOpenPlayParticipant :one
INSERT INTO reservation_participants (reservation_id, user_id)
SELECT r.id, ?1
FROM reservations r
JOIN reservation_types rt ON rt.id = r.reservation_type_id
WHERE r.facility_id = ?2
  AND r.open_play_rule_id = ?3
  AND r.start_time = ?4
  AND r.end_time = ?5
  AND rt.name = 'OPEN_PLAY'
LIMIT 1
RETURNING id, reservation_id, user_id, created_at, updated_at
`

type AddOpenPlayParticipantParams struct {
	UserID         int64         `json:"userId"`
	FacilityID     int64         `json:"facilityId"`
	OpenPlayRuleID sql.NullInt64 `json:"openPlayRuleId"`
	StartTime      time.Time     `json:"startTime"`
	EndTime        time.Time     `json:"endTime"`
}

func (q *Queries) AddOpenPlayParticipant(ctx context.Context, arg AddOpenPlayParticipantParams) (ReservationParticipant, error) {
	row := q.queryRow(ctx, q.addOpenPlayParticipantStmt, addOpenPlayParticipant,
		arg.UserID,
		arg.FacilityID,
		arg.OpenPlayRuleID,
		arg.StartTime,
		arg.EndTime,
	)
	var i ReservationParticipant
	err := row.Scan(
		&i.ID,
		&i.ReservationID,
		&i.UserID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const countOpenPlayReservationsForSession = `-- name: CountOpenPlayReservationsForSession :one
SELECT COUNT(*)
FROM reservations r
JOIN reservation_types rt ON rt.id = r.reservation_type_id
WHERE r.facility_id = ?1
  AND r.open_play_rule_id = ?2
  AND r.start_time = ?3
  AND r.end_time = ?4
  AND rt.name = 'OPEN_PLAY'
`

type CountOpenPlayReservationsForSessionParams struct {
	FacilityID     int64         `json:"facilityId"`
	OpenPlayRuleID sql.NullInt64 `json:"openPlayRuleId"`
	StartTime      time.Time     `json:"startTime"`
	EndTime        time.Time     `json:"endTime"`
}

func (q *Queries) CountOpenPlayReservationsForSession(ctx context.Context, arg CountOpenPlayReservationsForSessionParams) (int64, error) {
	row := q.queryRow(ctx, q.countOpenPlayReservationsForSessionStmt, countOpenPlayReservationsForSession,
		arg.FacilityID,
		arg.OpenPlayRuleID,
		arg.StartTime,
		arg.EndTime,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countUnreadStaffNotifications = `-- name: CountUnreadStaffNotifications :one
SELECT COUNT(*)
FROM staff_notifications
WHERE (?1 IS NULL OR facility_id = ?1)
  AND read = 0
`

func (q *Queries) CountUnreadStaffNotifications(ctx context.Context, facilityID interface{}) (int64, error) {
	row := q.queryRow(ctx, q.countUnreadStaffNotificationsStmt, countUnreadStaffNotifications, facilityID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createLessonCancelledNotification = `-- name: CreateLessonCancelledNotification :one
INSERT INTO staff_notifications (
    facility_id,
    notification_type,
    message,
    related_reservation_id,
    target_staff_id
)
VALUES (
    ?1,
    'lesson_cancelled',
    ?2,
    ?3,
    ?4
)
RETURNING id, facility_id, notification_type, message, related_session_id,
    related_reservation_id, target_staff_id, read, created_at, updated_at
`

type CreateLessonCancelledNotificationParams struct {
	FacilityID           int64         `json:"facilityId"`
	Message              string        `json:"message"`
	RelatedReservationID sql.NullInt64 `json:"relatedReservationId"`
	TargetStaffID        sql.NullInt64 `json:"targetStaffId"`
}

func (q *Queries) CreateLessonCancelledNotification(ctx context.Context, arg CreateLessonCancelledNotificationParams) (StaffNotification, error) {
	row := q.queryRow(ctx, q.createLessonCancelledNotificationStmt, createLessonCancelledNotification,
		arg.FacilityID,
		arg.Message,
		arg.RelatedReservationID,
		arg.TargetStaffID,
	)
	var i StaffNotification
	err := row.Scan(
		&i.ID,
		&i.FacilityID,
		&i.NotificationType,
		&i.Message,
		&i.RelatedSessionID,
		&i.RelatedReservationID,
		&i.TargetStaffID,
		&i.Read,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createOpenPlayAuditLog = `-- name: CreateOpenPlayAuditLog :one
INSERT INTO open_play_audit_log (
    session_id,
    action,
    before_state,
    after_state,
    reason
) VALUES (
    ?1,
    ?2,
    ?3,
    ?4,
    ?5
)
RETURNING id, session_id, action, before_state, after_state, reason, created_at
`

type CreateOpenPlayAuditLogParams struct {
	SessionID   int64          `json:"sessionId"`
	Action      string         `json:"action"`
	BeforeState sql.NullString `json:"beforeState"`
	AfterState  sql.NullString `json:"afterState"`
	Reason      sql.NullString `json:"reason"`
}

func (q *Queries) CreateOpenPlayAuditLog(ctx context.Context, arg CreateOpenPlayAuditLogParams) (OpenPlayAuditLog, error) {
	row := q.queryRow(ctx, q.createOpenPlayAuditLogStmt, createOpenPlayAuditLog,
		arg.SessionID,
		arg.Action,
		arg.BeforeState,
		arg.AfterState,
		arg.Reason,
	)
	var i OpenPlayAuditLog
	err := row.Scan(
		&i.ID,
		&i.SessionID,
		&i.Action,
		&i.BeforeState,
		&i.AfterState,
		&i.Reason,
		&i.CreatedAt,
	)
	return i, err
}

const createOpenPlaySession = `-- name: CreateOpenPlaySession :one
INSERT INTO open_play_sessions (
    facility_id,
    open_play_rule_id,
    start_time,
    end_time,
    status,
    current_court_count,
    auto_scale_override,
    cancelled_at,
    cancellation_reason
) VALUES (
    ?1,
    ?2,
    ?3,
    ?4,
    ?5,
    ?6,
    ?7,
    ?8,
    ?9
)
RETURNING id, facility_id, open_play_rule_id, start_time, end_time, status,
    current_court_count, auto_scale_override, cancelled_at, cancellation_reason,
    created_at, updated_at
`

type CreateOpenPlaySessionParams struct {
	FacilityID         int64          `json:"facilityId"`
	OpenPlayRuleID     int64          `json:"openPlayRuleId"`
	StartTime          time.Time      `json:"startTime"`
	EndTime            time.Time      `json:"endTime"`
	Status             string         `json:"status"`
	CurrentCourtCount  int64          `json:"currentCourtCount"`
	AutoScaleOverride  sql.NullBool   `json:"autoScaleOverride"`
	CancelledAt        sql.NullTime   `json:"cancelledAt"`
	CancellationReason sql.NullString `json:"cancellationReason"`
}

func (q *Queries) CreateOpenPlaySession(ctx context.Context, arg CreateOpenPlaySessionParams) (OpenPlaySession, error) {
	row := q.queryRow(ctx, q.createOpenPlaySessionStmt, createOpenPlaySession,
		arg.FacilityID,
		arg.OpenPlayRuleID,
		arg.StartTime,
		arg.EndTime,
		arg.Status,
		arg.CurrentCourtCount,
		arg.AutoScaleOverride,
		arg.CancelledAt,
		arg.CancellationReason,
	)
	var i OpenPlaySession
	err := row.Scan(
		&i.ID,
		&i.FacilityID,
		&i.OpenPlayRuleID,
		&i.StartTime,
		&i.EndTime,
		&i.Status,
		&i.CurrentCourtCount,
		&i.AutoScaleOverride,
		&i.CancelledAt,
		&i.CancellationReason,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createStaffNotification = `-- name: CreateStaffNotification :one
INSERT INTO staff_notifications (
    facility_id,
    notification_type,
    message,
    related_session_id
) VALUES (
    ?1,
    ?2,
    ?3,
    ?4
)
RETURNING id, facility_id, notification_type, message, related_session_id,
    related_reservation_id, target_staff_id, read, created_at, updated_at
`

type CreateStaffNotificationParams struct {
	FacilityID       int64         `json:"facilityId"`
	NotificationType string        `json:"notificationType"`
	Message          string        `json:"message"`
	RelatedSessionID sql.NullInt64 `json:"relatedSessionId"`
}

func (q *Queries) CreateStaffNotification(ctx context.Context, arg CreateStaffNotificationParams) (StaffNotification, error) {
	row := q.queryRow(ctx, q.createStaffNotificationStmt, createStaffNotification,
		arg.FacilityID,
		arg.NotificationType,
		arg.Message,
		arg.RelatedSessionID,
	)
	var i StaffNotification
	err := row.Scan(
		&i.ID,
		&i.FacilityID,
		&i.NotificationType,
		&i.Message,
		&i.RelatedSessionID,
		&i.RelatedReservationID,
		&i.TargetStaffID,
		&i.Read,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getOpenPlaySession = `-- name: GetOpenPlaySession :one
SELECT ops.id,
    ops.facility_id,
    ops.open_play_rule_id,
    ops.start_time,
    ops.end_time,
    ops.status,
    ops.current_court_count,
    ops.auto_scale_override,
    ops.cancelled_at,
    ops.cancellation_reason,
    ops.created_at,
    ops.updated_at,
    (
        SELECT COUNT(*)
        FROM reservation_participants rp
        JOIN reservations r ON r.id = rp.reservation_id
        JOIN reservation_types rt ON rt.id = r.reservation_type_id
        WHERE r.facility_id = ops.facility_id
          AND r.open_play_rule_id = ops.open_play_rule_id
          AND r.start_time = ops.start_time
          AND r.end_time = ops.end_time
          AND rt.name = 'OPEN_PLAY'
    ) AS participant_count
FROM open_play_sessions ops
WHERE ops.id = ?1
  AND ops.facility_id = ?2
`

type GetOpenPlaySessionParams struct {
	ID         int64 `json:"id"`
	FacilityID int64 `json:"facilityId"`
}

type GetOpenPlaySessionRow struct {
	ID                 int64          `json:"id"`
	FacilityID         int64          `json:"facilityId"`
	OpenPlayRuleID     int64          `json:"openPlayRuleId"`
	StartTime          time.Time      `json:"startTime"`
	EndTime            time.Time      `json:"endTime"`
	Status             string         `json:"status"`
	CurrentCourtCount  int64          `json:"currentCourtCount"`
	AutoScaleOverride  sql.NullBool   `json:"autoScaleOverride"`
	CancelledAt        sql.NullTime   `json:"cancelledAt"`
	CancellationReason sql.NullString `json:"cancellationReason"`
	CreatedAt          time.Time      `json:"createdAt"`
	UpdatedAt          time.Time      `json:"updatedAt"`
	ParticipantCount   int64          `json:"participantCount"`
}

func (q *Queries) GetOpenPlaySession(ctx context.Context, arg GetOpenPlaySessionParams) (GetOpenPlaySessionRow, error) {
	row := q.queryRow(ctx, q.getOpenPlaySessionStmt, getOpenPlaySession, arg.ID, arg.FacilityID)
	var i GetOpenPlaySessionRow
	err := row.Scan(
		&i.ID,
		&i.FacilityID,
		&i.OpenPlayRuleID,
		&i.StartTime,
		&i.EndTime,
		&i.Status,
		&i.CurrentCourtCount,
		&i.AutoScaleOverride,
		&i.CancelledAt,
		&i.CancellationReason,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ParticipantCount,
	)
	return i, err
}

const getStaffNotificationByID = `-- name: GetStaffNotificationByID :one
SELECT id, facility_id, notification_type, message, related_session_id,
    related_reservation_id, target_staff_id, read, created_at, updated_at
FROM staff_notifications
WHERE id = ?1
`

func (q *Queries) GetStaffNotificationByID(ctx context.Context, id int64) (StaffNotification, error) {
	row := q.queryRow(ctx, q.getStaffNotificationByIDStmt, getStaffNotificationByID, id)
	var i StaffNotification
	err := row.Scan(
		&i.ID,
		&i.FacilityID,
		&i.NotificationType,
		&i.Message,
		&i.RelatedSessionID,
		&i.RelatedReservationID,
		&i.TargetStaffID,
		&i.Read,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const isMemberOpenPlayParticipant = `-- name: IsMemberOpenPlayParticipant :one
SELECT EXISTS (
    SELECT 1
    FROM open_play_sessions ops
    JOIN reservations r
      ON r.facility_id = ops.facility_id
     AND r.open_play_rule_id = ops.open_play_rule_id
     AND r.start_time = ops.start_time
     AND r.end_time = ops.end_time
    JOIN reservation_types rt ON rt.id = r.reservation_type_id
    JOIN reservation_participants rp ON rp.reservation_id = r.id
    WHERE ops.id = ?1
      AND ops.facility_id = ?2
      AND rt.name = 'OPEN_PLAY'
      AND rp.user_id = ?3
) AS is_participant
`

type IsMemberOpenPlayParticipantParams struct {
	SessionID  int64 `json:"sessionId"`
	FacilityID int64 `json:"facilityId"`
	UserID     int64 `json:"userId"`
}

func (q *Queries) IsMemberOpenPlayParticipant(ctx context.Context, arg IsMemberOpenPlayParticipantParams) (int64, error) {
	row := q.queryRow(ctx, q.isMemberOpenPlayParticipantStmt, isMemberOpenPlayParticipant, arg.SessionID, arg.FacilityID, arg.UserID)
	var is_participant int64
	err := row.Scan(&is_participant)
	return is_participant, err
}

const listDistinctFacilitiesWithScheduledSessions = `-- name: ListDistinctFacilitiesWithScheduledSessions :many
SELECT DISTINCT facility_id
FROM open_play_sessions
WHERE status = 'scheduled'
  AND start_time > ?1
ORDER BY facility_id
`

func (q *Queries) ListDistinctFacilitiesWithScheduledSessions(ctx context.Context, comparisonTime time.Time) ([]int64, error) {
	rows, err := q.query(ctx, q.listDistinctFacilitiesWithScheduledSessionsStmt, listDistinctFacilitiesWithScheduledSessions, comparisonTime)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int64
	for rows.Next() {
		var facility_id int64
		if err := rows.Scan(&facility_id); err != nil {
			return nil, err
		}
		items = append(items, facility_id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMemberUpcomingOpenPlaySessions = `-- name: ListMemberUpcomingOpenPlaySessions :many
SELECT ops.id,
    ops.start_time,
    ops.end_time,
    ops.status,
    opr.name AS rule_name,
    (
        SELECT COUNT(*)
        FROM reservation_participants rp
        JOIN reservations r ON r.id = rp.reservation_id
        JOIN reservation_types rt ON rt.id = r.reservation_type_id
        WHERE r.facility_id = ops.facility_id
          AND r.open_play_rule_id = ops.open_play_rule_id
          AND r.start_time = ops.start_time
          AND r.end_time = ops.end_time
          AND rt.name = 'OPEN_PLAY'
    ) AS participant_count,
    opr.min_participants
FROM open_play_sessions ops
JOIN open_play_rules opr
  ON ops.open_play_rule_id = opr.id
WHERE ops.facility_id IN (/*SLICE:facility_ids*/?)
  AND ops.status = 'scheduled'
  AND ops.start_time > ?2
ORDER BY ops.start_time
`

type ListMemberUpcomingOpenPlaySessionsParams struct {
	FacilityIds    []int64   `json:"facilityIds"`
	ComparisonTime time.Time `json:"comparisonTime"`
}

type ListMemberUpcomingOpenPlaySessionsRow struct {
	ID               int64     `json:"id"`
	StartTime        time.Time `json:"startTime"`
	EndTime          time.Time `json:"endTime"`
	Status           string    `json:"status"`
	RuleName         string    `json:"ruleName"`
	ParticipantCount int64     `json:"participantCount"`
	MinParticipants  int64     `json:"minParticipants"`
}

// Empty facility_ids intentionally yields zero rows (caller should prefilter).
func (q *Queries) ListMemberUpcomingOpenPlaySessions(ctx context.Context, arg ListMemberUpcomingOpenPlaySessionsParams) ([]ListMemberUpcomingOpenPlaySessionsRow, error) {
	query := listMemberUpcomingOpenPlaySessions
	var queryParams []interface{}
	if len(arg.FacilityIds) > 0 {
		for _, v := range arg.FacilityIds {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:facility_ids*/?", strings.Repeat(",?", len(arg.FacilityIds))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:facility_ids*/?", "NULL", 1)
	}
	queryParams = append(queryParams, arg.ComparisonTime)
	rows, err := q.query(ctx, nil, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListMemberUpcomingOpenPlaySessionsRow
	for rows.Next() {
		var i ListMemberUpcomingOpenPlaySessionsRow
		if err := rows.Scan(
			&i.ID,
			&i.StartTime,
			&i.EndTime,
			&i.Status,
			&i.RuleName,
			&i.ParticipantCount,
			&i.MinParticipants,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOpenPlayAuditLog = `-- name: ListOpenPlayAuditLog :many
SELECT open_play_audit_log.id,
    open_play_audit_log.session_id,
    open_play_audit_log.action,
    open_play_audit_log.before_state,
    open_play_audit_log.after_state,
    open_play_audit_log.reason,
    open_play_audit_log.created_at
FROM open_play_audit_log
JOIN open_play_sessions
  ON open_play_audit_log.session_id = open_play_sessions.id
WHERE open_play_audit_log.session_id = ?1
  AND open_play_sessions.facility_id = ?2
ORDER BY open_play_audit_log.created_at
`

type ListOpenPlayAuditLogParams struct {
	SessionID  int64 `json:"sessionId"`
	FacilityID int64 `json:"facilityId"`
}

func (q *Queries) ListOpenPlayAuditLog(ctx context.Context, arg ListOpenPlayAuditLogParams) ([]OpenPlayAuditLog, error) {
	rows, err := q.query(ctx, q.listOpenPlayAuditLogStmt, listOpenPlayAuditLog, arg.SessionID, arg.FacilityID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []OpenPlayAuditLog
	for rows.Next() {
		var i OpenPlayAuditLog
		if err := rows.Scan(
			&i.ID,
			&i.SessionID,
			&i.Action,
			&i.BeforeState,
			&i.AfterState,
			&i.Reason,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOpenPlayParticipants = `-- name: ListOpenPlayParticipants :many
SELECT u.id,
    u.first_name,
    u.last_name,
    u.photo_url
FROM reservation_participants rp
JOIN reservations r ON r.id = rp.reservation_id
JOIN reservation_types rt ON rt.id = r.reservation_type_id
JOIN users u ON u.id = rp.user_id
WHERE r.facility_id = ?1
  AND r.open_play_rule_id = ?2
  AND r.start_time = ?3
  AND r.end_time = ?4
  AND rt.name = 'OPEN_PLAY'
ORDER BY u.last_name, u.first_name
`

type ListOpenPlayParticipantsParams struct {
	FacilityID     int64         `json:"facilityId"`
	OpenPlayRuleID sql.NullInt64 `json:"openPlayRuleId"`
	StartTime      time.Time     `json:"startTime"`
	EndTime        time.Time     `json:"endTime"`
}

type ListOpenPlayParticipantsRow struct {
	ID        int64          `json:"id"`
	FirstName string         `json:"firstName"`
	LastName  string         `json:"lastName"`
	PhotoUrl  sql.NullString `json:"photoUrl"`
}

func (q *Queries) ListOpenPlayParticipants(ctx context.Context, arg ListOpenPlayParticipantsParams) ([]ListOpenPlayParticipantsRow, error) {
	rows, err := q.query(ctx, q.listOpenPlayParticipantsStmt, listOpenPlayParticipants,
		arg.FacilityID,
		arg.OpenPlayRuleID,
		arg.StartTime,
		arg.EndTime,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListOpenPlayParticipantsRow
	for rows.Next() {
		var i ListOpenPlayParticipantsRow
		if err := rows.Scan(
			&i.ID,
			&i.FirstName,
			&i.LastName,
			&i.PhotoUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOpenPlaySessions = `-- name: ListOpenPlaySessions :many
SELECT id, facility_id, open_play_rule_id, start_time, end_time, status,
    current_court_count, auto_scale_override, cancelled_at, cancellation_reason,
    created_at, updated_at
FROM open_play_sessions
WHERE facility_id = ?1
ORDER BY start_time
`

func (q *Queries) ListOpenPlaySessions(ctx context.Context, facilityID int64) ([]OpenPlaySession, error) {
	rows, err := q.query(ctx, q.listOpenPlaySessionsStmt, listOpenPlaySessions, facilityID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []OpenPlaySession
	for rows.Next() {
		var i OpenPlaySession
		if err := rows.Scan(
			&i.ID,
			&i.FacilityID,
			&i.OpenPlayRuleID,
			&i.StartTime,
			&i.EndTime,
			&i.Status,
			&i.CurrentCourtCount,
			&i.AutoScaleOverride,
			&i.CancelledAt,
			&i.CancellationReason,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOpenPlaySessionsApproachingCutoff = `-- name: ListOpenPlaySessionsApproachingCutoff :many
SELECT open_play_sessions.id,
    open_play_sessions.facility_id,
    open_play_sessions.open_play_rule_id,
    open_play_sessions.start_time,
    open_play_sessions.end_time,
    open_play_sessions.status,
    open_play_sessions.current_court_count,
    open_play_sessions.auto_scale_override,
    open_play_sessions.cancelled_at,
    open_play_sessions.cancellation_reason,
    open_play_sessions.created_at,
    open_play_sessions.updated_at
FROM open_play_sessions
JOIN open_play_rules
  ON open_play_sessions.open_play_rule_id = open_play_rules.id
WHERE open_play_sessions.facility_id = ?1
  AND open_play_sessions.status = 'scheduled'
  AND open_play_sessions.start_time > ?2
  AND open_play_sessions.start_time <= datetime(
        ?2,
        '+' || open_play_rules.cancellation_cutoff_minutes || ' minutes'
      )
ORDER BY open_play_sessions.start_time
`

type ListOpenPlaySessionsApproachingCutoffParams struct {
	FacilityID     int64     `json:"facilityId"`
	ComparisonTime time.Time `json:"comparisonTime"`
}

func (q *Queries) ListOpenPlaySessionsApproachingCutoff(ctx context.Context, arg ListOpenPlaySessionsApproachingCutoffParams) ([]OpenPlaySession, error) {
	rows, err := q.query(ctx, q.listOpenPlaySessionsApproachingCutoffStmt, listOpenPlaySessionsApproachingCutoff, arg.FacilityID, arg.ComparisonTime)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []OpenPlaySession
	for rows.Next() {
		var i OpenPlaySession
		if err := rows.Scan(
			&i.ID,
			&i.FacilityID,
			&i.OpenPlayRuleID,
			&i.StartTime,
			&i.EndTime,
			&i.Status,
			&i.CurrentCourtCount,
			&i.AutoScaleOverride,
			&i.CancelledAt,
			&i.CancellationReason,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listStaffNotifications = `-- name: ListStaffNotifications :many
SELECT id, facility_id, notification_type, message, related_session_id,
    related_reservation_id, target_staff_id, read, created_at, updated_at
FROM staff_notifications
WHERE facility_id = ?1
ORDER BY created_at DESC
LIMIT ?3 OFFSET ?2
`

type ListStaffNotificationsParams struct {
	FacilityID int64 `json:"facilityId"`
	Offset     int64 `json:"offset"`
	Limit      int64 `json:"limit"`
}

func (q *Queries) ListStaffNotifications(ctx context.Context, arg ListStaffNotificationsParams) ([]StaffNotification, error) {
	rows, err := q.query(ctx, q.listStaffNotificationsStmt, listStaffNotifications, arg.FacilityID, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []StaffNotification
	for rows.Next() {
		var i StaffNotification
		if err := rows.Scan(
			&i.ID,
			&i.FacilityID,
			&i.NotificationType,
			&i.Message,
			&i.RelatedSessionID,
			&i.RelatedReservationID,
			&i.TargetStaffID,
			&i.Read,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listStaffNotificationsForFacilityOrCorporate = `-- name: ListStaffNotificationsForFacilityOrCorporate :many
SELECT id, facility_id, notification_type, message, related_session_id,
    related_reservation_id, target_staff_id, read, created_at, updated_at
FROM staff_notifications
WHERE ?1 IS NULL
   OR facility_id = ?1
ORDER BY created_at DESC
LIMIT ?3 OFFSET ?2
`

type ListStaffNotificationsForFacilityOrCorporateParams struct {
	FacilityID interface{} `json:"facilityId"`
	Offset     int64       `json:"offset"`
	Limit      int64       `json:"limit"`
}

func (q *Queries) ListStaffNotificationsForFacilityOrCorporate(ctx context.Context, arg ListStaffNotificationsForFacilityOrCorporateParams) ([]StaffNotification, error) {
	rows, err := q.query(ctx, q.listStaffNotificationsForFacilityOrCorporateStmt, listStaffNotificationsForFacilityOrCorporate, arg.FacilityID, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []StaffNotification
	for rows.Next() {
		var i StaffNotification
		if err := rows.Scan(
			&i.ID,
			&i.FacilityID,
			&i.NotificationType,
			&i.Message,
			&i.RelatedSessionID,
			&i.RelatedReservationID,
			&i.TargetStaffID,
			&i.Read,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listStaffNotificationsForStaff = `-- name: ListStaffNotificationsForStaff :many
SELECT id, facility_id, notification_type, message, related_session_id,
    related_reservation_id, target_staff_id, read, created_at, updated_at
FROM staff_notifications
WHERE target_staff_id = ?1
ORDER BY created_at DESC
LIMIT ?3 OFFSET ?2
`

type ListStaffNotificationsForStaffParams struct {
	TargetStaffID sql.NullInt64 `json:"targetStaffId"`
	Offset        int64         `json:"offset"`
	Limit         int64         `json:"limit"`
}

func (q *Queries) ListStaffNotificationsForStaff(ctx context.Context, arg ListStaffNotificationsForStaffParams) ([]StaffNotification, error) {
	rows, err := q.query(ctx, q.listStaffNotificationsForStaffStmt, listStaffNotificationsForStaff, arg.TargetStaffID, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []StaffNotification
	for rows.Next() {
		var i StaffNotification
		if err := rows.Scan(
			&i.ID,
			&i.FacilityID,
			&i.NotificationType,
			&i.Message,
			&i.RelatedSessionID,
			&i.RelatedReservationID,
			&i.TargetStaffID,
			&i.Read,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markStaffNotificationAsRead = `-- name: MarkStaffNotificationAsRead :one
UPDATE staff_notifications
SET read = 1,
    updated_at = CURRENT_TIMESTAMP
WHERE id = ?1
  AND facility_id = ?2
RETURNING id, facility_id, notification_type, message, related_session_id,
    related_reservation_id, target_staff_id, read, created_at, updated_at
`

type MarkStaffNotificationAsReadParams struct {
	ID         int64 `json:"id"`
	FacilityID int64 `json:"facilityId"`
}

func (q *Queries) MarkStaffNotificationAsRead(ctx context.Context, arg MarkStaffNotificationAsReadParams) (StaffNotification, error) {
	row := q.queryRow(ctx, q.markStaffNotificationAsReadStmt, markStaffNotificationAsRead, arg.ID, arg.FacilityID)
	var i StaffNotification
	err := row.Scan(
		&i.ID,
		&i.FacilityID,
		&i.NotificationType,
		&i.Message,
		&i.RelatedSessionID,
		&i.RelatedReservationID,
		&i.TargetStaffID,
		&i.Read,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const removeOpenPlayParticipant = `-- name: RemoveOpenPlayParticipant :execrows
DELETE FROM reservation_participants
WHERE reservation_id = (
    SELECT r.id
    FROM reservations r
    JOIN reservation_types rt ON rt.id = r.reservation_type_id
    WHERE r.facility_id = ?1
      AND r.open_play_rule_id = ?2
      AND r.start_time = ?3
      AND r.end_time = ?4
      AND rt.name = 'OPEN_PLAY'
    LIMIT 1
)
  AND user_id = ?5
`

type RemoveOpenPlayParticipantParams struct {
	FacilityID     int64         `json:"facilityId"`
	OpenPlayRuleID sql.NullInt64 `json:"openPlayRuleId"`
	StartTime      time.Time     `json:"startTime"`
	EndTime        time.Time     `json:"endTime"`
	UserID         int64         `json:"userId"`
}

func (q *Queries) RemoveOpenPlayParticipant(ctx context.Context, arg RemoveOpenPlayParticipantParams) (int64, error) {
	result, err := q.exec(ctx, q.removeOpenPlayParticipantStmt, removeOpenPlayParticipant,
		arg.FacilityID,
		arg.OpenPlayRuleID,
		arg.StartTime,
		arg.EndTime,
		arg.UserID,
	)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const updateOpenPlaySessionCourtCount = `-- name: UpdateOpenPlaySessionCourtCount :one
UPDATE open_play_sessions
SET current_court_count = ?1,
    updated_at = CURRENT_TIMESTAMP
WHERE id = ?2
  AND facility_id = ?3
RETURNING id, facility_id, open_play_rule_id, start_time, end_time, status,
    current_court_count, auto_scale_override, cancelled_at, cancellation_reason,
    created_at, updated_at
`

type UpdateOpenPlaySessionCourtCountParams struct {
	CurrentCourtCount int64 `json:"currentCourtCount"`
	ID                int64 `json:"id"`
	FacilityID        int64 `json:"facilityId"`
}

func (q *Queries) UpdateOpenPlaySessionCourtCount(ctx context.Context, arg UpdateOpenPlaySessionCourtCountParams) (OpenPlaySession, error) {
	row := q.queryRow(ctx, q.updateOpenPlaySessionCourtCountStmt, updateOpenPlaySessionCourtCount, arg.CurrentCourtCount, arg.ID, arg.FacilityID)
	var i OpenPlaySession
	err := row.Scan(
		&i.ID,
		&i.FacilityID,
		&i.OpenPlayRuleID,
		&i.StartTime,
		&i.EndTime,
		&i.Status,
		&i.CurrentCourtCount,
		&i.AutoScaleOverride,
		&i.CancelledAt,
		&i.CancellationReason,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateOpenPlaySessionStatus = `-- name: UpdateOpenPlaySessionStatus :one
UPDATE open_play_sessions
SET status = ?1,
    cancelled_at = ?2,
    cancellation_reason = ?3,
    updated_at = CURRENT_TIMESTAMP
WHERE id = ?4
  AND facility_id = ?5
RETURNING id, facility_id, open_play_rule_id, start_time, end_time, status,
    current_court_count, auto_scale_override, cancelled_at, cancellation_reason,
    created_at, updated_at
`

type UpdateOpenPlaySessionStatusParams struct {
	Status             string         `json:"status"`
	CancelledAt        sql.NullTime   `json:"cancelledAt"`
	CancellationReason sql.NullString `json:"cancellationReason"`
	ID                 int64          `json:"id"`
	FacilityID         int64          `json:"facilityId"`
}

func (q *Queries) UpdateOpenPlaySessionStatus(ctx context.Context, arg UpdateOpenPlaySessionStatusParams) (OpenPlaySession, error) {
	row := q.queryRow(ctx, q.updateOpenPlaySessionStatusStmt, updateOpenPlaySessionStatus,
		arg.Status,
		arg.CancelledAt,
		arg.CancellationReason,
		arg.ID,
		arg.FacilityID,
	)
	var i OpenPlaySession
	err := row.Scan(
		&i.ID,
		&i.FacilityID,
		&i.OpenPlayRuleID,
		&i.StartTime,
		&i.EndTime,
		&i.Status,
		&i.CurrentCourtCount,
		&i.AutoScaleOverride,
		&i.CancelledAt,
		&i.CancellationReason,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateSessionAutoScaleOverride = `-- name: UpdateSessionAutoScaleOverride :one
UPDATE open_play_sessions
SET auto_scale_override = ?1,
    updated_at = CURRENT_TIMESTAMP
WHERE id = ?2
  AND facility_id = ?3
RETURNING id, facility_id, open_play_rule_id, start_time, end_time, status,
    current_court_count, auto_scale_override, cancelled_at, cancellation_reason,
    created_at, updated_at
`

type UpdateSessionAutoScaleOverrideParams struct {
	AutoScaleOverride sql.NullBool `json:"autoScaleOverride"`
	ID                int64        `json:"id"`
	FacilityID        int64        `json:"facilityId"`
}

func (q *Queries) UpdateSessionAutoScaleOverride(ctx context.Context, arg UpdateSessionAutoScaleOverrideParams) (OpenPlaySession, error) {
	row := q.queryRow(ctx, q.updateSessionAutoScaleOverrideStmt, updateSessionAutoScaleOverride, arg.AutoScaleOverride, arg.ID, arg.FacilityID)
	var i OpenPlaySession
	err := row.Scan(
		&i.ID,
		&i.FacilityID,
		&i.OpenPlayRuleID,
		&i.StartTime,
		&i.EndTime,
		&i.Status,
		&i.CurrentCourtCount,
		&i.AutoScaleOverride,
		&i.CancelledAt,
		&i.CancellationReason,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
